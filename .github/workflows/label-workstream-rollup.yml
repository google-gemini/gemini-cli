name: 'Label Workstream Rollup'

on:
  issues:
    types: ['opened', 'edited', 'reopened']
  schedule:
    - cron: '0 * * * *' # Runs every hour
  workflow_dispatch:

concurrency:
  group: label-workstream-rollup
  cancel-in-progress: false

jobs:
  labeler:
    name: Apply or Remove Workstream Rollup Label
    runs-on: ubuntu-latest
    permissions:
      issues: write

    steps:
      - name: 'Manage Workstream Rollup Label'
        uses: actions/github-script@v7
        with:
          script: |
            const labelToAdd = 'workstream-rollup';
            const allowedParentUrls = [
              'https://github.com/google-gemini/gemini-cli/issues/15374',
              'https://github.com/google-gemini/gemini-cli/issues/15456',
              'https://github.com/google-gemini/gemini-cli/issues/15324',
              'https://github.com/google-gemini/gemini-cli/issues/17202',
              'https://github.com/google-gemini/gemini-cli/issues/17203'
            ];

            const sleep = ms => new Promise(r => setTimeout(r, ms));

            // ‚úÖ Ensure the label exists
            async function ensureLabelExists(owner, repo, name) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name });
                console.log(`Label '${name}' already exists.`);
              } catch (error) {
                if (error.status === 404) {
                  console.log(`Label '${name}' not found. Creating it...`);
                  await github.rest.issues.createLabel({
                    owner,
                    repo,
                    name,
                    color: '0e8a16',
                    description: 'Automatically applied to issues under approved workstream rollups'
                  });
                  console.log(`‚úÖ Label '${name}' created.`);
                } else {
                  throw error;
                }
              }
            }

            // üß© Skip PRs
            if (context.payload.issue && context.payload.issue.pull_request) {
              console.log('Skipping pull request events.');
              return;
            }

            async function checkAndLabel(issue, owner, repo) {
              if (!issue) return;
              const issueNumber = issue.number;
              let isWorkstream = false;
              let trace = [];

              // Traverse parents
              let currentParent = issue.parent;
              while (currentParent) {
                trace.push(currentParent.url);
                if (allowedParentUrls.includes(currentParent.url)) {
                  isWorkstream = true;
                  break;
                }
                currentParent = currentParent.parent;
              }

              // Fetch labels for the issue
              const { data: labels } = await github.rest.issues.listLabelsOnIssue({
                owner,
                repo,
                issue_number: issueNumber,
              });

              const hasLabel = labels.some(l => l.name === labelToAdd);

              if (isWorkstream && !hasLabel) {
                console.log(`‚úÖ Adding '${labelToAdd}' to #${issueNumber} (trace: ${trace.join(' -> ')})`);
                await ensureLabelExists(owner, repo, labelToAdd);
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  labels: [labelToAdd],
                });
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  body: `üè∑Ô∏è Automatically labeled as **${labelToAdd}** because it belongs to an approved workstream rollup.`,
                });
              } else if (!isWorkstream && hasLabel) {
                console.log(`üßπ Removing '${labelToAdd}' from #${issueNumber} (no longer in allowed rollups).`);
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  name: labelToAdd,
                });
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  body: `üö´ Removed label **${labelToAdd}** because the issue no longer belongs to an approved workstream rollup.`,
                });
              } else {
                console.log(`‚ÑπÔ∏è No change for issue #${issueNumber}. Workstream=${isWorkstream}`);
              }
            }

            async function processSingleIssue(owner, repo, number) {
              const query = `
                query($owner:String!, $repo:String!, $number:Int!) {
                  repository(owner:$owner, name:$repo) {
                    issue(number:$number) {
                      number
                      parent { url parent { url parent { url parent { url parent { url } } } } }
                    }
                  }
                }
              `;
              const result = await github.graphql(query, { owner, repo, number });
              const issue = result?.repository?.issue;
              if (!issue) {
                console.log(`‚ö†Ô∏è Issue #${number} not found.`);
                return;
              }
              await checkAndLabel(issue, owner, repo);
            }

            async function processAllOpenIssues(owner, repo) {
              const query = `
                query($owner:String!, $repo:String!, $cursor:String) {
                  repository(owner:$owner, name:$repo) {
                    issues(first: 100, states: OPEN, after: $cursor) {
                      pageInfo { hasNextPage endCursor }
                      nodes {
                        number
                        parent { url parent { url parent { url parent { url parent { url } } } } }
                      }
                    }
                  }
                }
              `;

              await ensureLabelExists(owner, repo, labelToAdd);
              let hasNextPage = true;
              let cursor = null;

              while (hasNextPage) {
                const result = await github.graphql(query, { owner, repo, cursor });
                const issues = result?.repository?.issues?.nodes || [];

                console.log(`üîç Checking ${issues.length} open issues...`);
                for (const issue of issues) {
                  try {
                    await checkAndLabel(issue, owner, repo);
                  } catch (e) {
                    console.error(`‚ö†Ô∏è Failed on #${issue.number}:`, e);
                  }
                }

                hasNextPage = result.repository.issues.pageInfo.hasNextPage;
                cursor = result.repository.issues.pageInfo.endCursor;
                await sleep(1000); // prevent hitting rate limits
              }
            }

            try {
              const { owner, repo } = context.repo;
              if (context.eventName === 'issues') {
                const num = context.payload.issue.number;
                console.log(`Processing single issue event for #${num}...`);
                await processSingleIssue(owner, repo, num);
              } else {
                console.log('Running scheduled/manual job ‚Äî scanning all open issues.');
                await processAllOpenIssues(owner, repo);
              }
              console.log('üéâ Label rollup maintenance complete.');
            } catch (err) {
              core.setFailed(`Workflow failed: ${err.message}`);
            }
