import asyncio
import logging
import random
import time
from collections.abc import Callable
from typing import Any

from pydantic import BaseModel, Field

from crisalida_lib.symbolic_language.living_symbols import LivingSymbolRuntime
from crisalida_lib.symbolic_language.types import (
    EVAExperience,
    QualiaState,
    RealityBytecode,
)

logger = logging.getLogger(__name__)


class Problem(BaseModel):
    """Represents a synthetic problem generated for the agent."""

    problem_id: str = Field(..., description="Unique identifier for the problem.")
    description: str = Field(..., description="Description of the problem.")
    context: dict[str, Any] = Field(
        default_factory=dict,
        description="Contextual data for the problem (e.g., code snippets, requirements).",
    )
    expected_solution_format: str = Field(
        ...,
        description="Expected format of the solution (e.g., 'python_code', 'json_data').",
    )
    difficulty: str = Field("medium", description="Difficulty level of the problem.")
    tags: list[str] = Field(
        default_factory=list, description="Tags for problem classification."
    )


class Solution(BaseModel):
    """Represents a solution to a synthetic problem."""

    solution_id: str = Field(..., description="Unique identifier for the solution.")
    problem_id: str = Field(
        ..., description="ID of the problem this solution addresses."
    )
    content: str = Field(
        ..., description="The actual solution content (e.g., code, data)."
    )
    metadata: dict[str, Any] = Field(
        default_factory=dict,
        description="Metadata about the solution (e.g., performance metrics, generated by).",
    )
    score: int = Field(0, description="Evaluation score for the solution.")
    feedback: str = Field("", description="Feedback from the evaluation.")


class SyntheticGym:
    """
    Advanced synthetic gym environment for generating diverse problems and evaluating solutions.
    Supports multiple problem types, adaptive difficulty, and detailed feedback.
    """

    def __init__(self):
        self.problems: dict[str, Problem] = {}
        self.solutions: dict[str, Solution] = {}
        self.problem_counter = 0
        self.solution_counter = 0
        self.history: list[dict[str, Any]] = []
        logger.info("üèãÔ∏è SyntheticGym initialized.")

    async def generate_problem(
        self,
        problem_type: str,
        difficulty: str = "medium",
        tags: list[str] | None = None,
        context: dict[str, Any] | None = None,
    ) -> Problem:
        """
        Generates a new problem with adaptive context and tagging.
        """
        await asyncio.sleep(0.5 + random.uniform(0, 0.5))  # Simulate external AI call
        self.problem_counter += 1
        problem_id = f"problem_{self.problem_counter}"
        description = self._create_problem_description(problem_type, difficulty)
        context = context or self._generate_context(problem_type, difficulty)
        expected_solution_format = self._infer_solution_format(problem_type)
        tags = tags or [problem_type, difficulty]
        problem = Problem(
            problem_id=problem_id,
            description=description,
            context=context,
            expected_solution_format=expected_solution_format,
            difficulty=difficulty,
            tags=tags,
        )
        self.problems[problem_id] = problem
        logger.info(f"Generated problem: {problem_id} ({problem_type}, {difficulty})")
        return problem

    async def evaluate_solution(
        self,
        problem_id: str,
        solution_content: str,
        agent_name: str | None = None,
    ) -> dict[str, Any]:
        """
        Evaluates a solution with simulated metrics, feedback, and scoring.
        """
        await asyncio.sleep(
            0.5 + random.uniform(0, 0.5)
        )  # Simulate external AI evaluation
        problem = self.problems.get(problem_id)
        if not problem:
            return {"success": False, "message": "Problem not found.", "score": 0}
        # Simulated evaluation logic
        correctness = self._simulate_correctness(problem, solution_content)
        performance = self._simulate_performance(problem, solution_content)
        score = int(correctness * 70 + performance * 30)
        feedback = self._generate_feedback(
            problem, solution_content, correctness, performance
        )
        self.solution_counter += 1
        solution_id = f"solution_{self.solution_counter}"
        solution = Solution(
            solution_id=solution_id,
            problem_id=problem_id,
            content=solution_content,
            metadata={
                "evaluation_score": score,
                "evaluation_feedback": feedback,
                "timestamp": time.time(),
                "agent_name": agent_name or "anonymous",
                "performance_metric": performance,
            },
            score=score,
            feedback=feedback,
        )
        self.solutions[solution_id] = solution
        self.history.append(
            {
                "problem_id": problem_id,
                "solution_id": solution_id,
                "score": score,
                "feedback": feedback,
                "timestamp": time.time(),
            }
        )
        logger.info(
            f"Evaluated solution {solution_id} for problem {problem_id}. Score: {score}"
        )
        return {
            "success": True,
            "message": feedback,
            "score": score,
            "solution_id": solution_id,
            "performance": performance,
        }

    def get_problem_history(self) -> list[dict[str, Any]]:
        """Returns the history of problems and solutions."""
        return self.history.copy()

    def _create_problem_description(self, problem_type: str, difficulty: str) -> str:
        templates = {
            "code_refactoring": "Refactor the provided code to improve readability and efficiency.",
            "bug_fixing": "Identify and fix bugs in the given code snippet.",
            "data_analysis": "Analyze the provided dataset and extract key insights.",
            "logic_puzzle": "Solve the presented logic puzzle using reasoning.",
            "text_generation": "Generate a coherent text based on the given prompt.",
        }
        base = templates.get(problem_type, f"Solve a {problem_type} problem.")
        return f"{base} Difficulty: {difficulty.capitalize()}."

    def _generate_context(self, problem_type: str, difficulty: str) -> dict[str, Any]:
        # Simulate context generation
        context = {
            "hint": f"This is a simulated {problem_type} problem.",
            "difficulty": difficulty,
            "requirements": [],
        }
        if problem_type == "code_refactoring":
            context["code"] = "def bad_code():\n    x=1\n    y=2\n    return x+y"
            context["requirements"] = ["Improve variable naming", "Add docstrings"]
        elif problem_type == "bug_fixing":
            context["code"] = "def buggy():\n    return 1/0"
            context["requirements"] = ["Fix division by zero"]
        elif problem_type == "data_analysis":
            context["data"] = [random.randint(1, 100) for _ in range(10)]
            context["requirements"] = ["Calculate mean", "Find max value"]
        elif problem_type == "logic_puzzle":
            context["puzzle"] = (
                "If all bloops are blips and all blips are blops, are all bloops blops?"
            )
            context["requirements"] = ["Deductive reasoning"]
        elif problem_type == "text_generation":
            context["prompt"] = (
                "Write a short story about a synthetic agent in a digital gym."
            )
            context["requirements"] = ["Creativity", "Coherence"]
        return context

    def _infer_solution_format(self, problem_type: str) -> str:
        if "code" in problem_type:
            return "python_code"
        elif "data" in problem_type:
            return "json_data"
        elif "text" in problem_type or "generation" in problem_type:
            return "text"
        elif "logic" in problem_type:
            return "text"
        return "text"

    def _simulate_correctness(self, problem: Problem, solution_content: str) -> float:
        # Simulate correctness based on keywords and expected format
        if problem.expected_solution_format == "python_code":
            return (
                1.0
                if "def" in solution_content and "return" in solution_content
                else 0.5
            )
        if problem.expected_solution_format == "json_data":
            return 1.0 if "{" in solution_content and "}" in solution_content else 0.5
        if problem.expected_solution_format == "text":
            return 1.0 if len(solution_content.split()) > 10 else 0.6
        return 0.5

    def _simulate_performance(self, problem: Problem, solution_content: str) -> float:
        # Simulate performance metric (e.g., efficiency, speed)
        return random.uniform(0.7, 1.0)

    def _generate_feedback(
        self,
        problem: Problem,
        solution_content: str,
        correctness: float,
        performance: float,
    ) -> str:
        if correctness == 1.0 and performance > 0.8:
            return (
                "Excellent solution! Meets all requirements and performs efficiently."
            )
        elif correctness == 1.0:
            return "Correct solution, but could be more efficient."
        elif correctness >= 0.7:
            return "Partially correct solution. Review requirements for full marks."
        else:
            return "Solution needs significant improvement."


class SyntheticGymEVA(SyntheticGym):
    """
    SyntheticGymEVA - Entorno de gym sint√©tico perfeccionado y extendido para integraci√≥n con EVA.
    Orquesta la generaci√≥n, evaluaci√≥n y simulaci√≥n de problemas/soluciones como experiencias vivientes (RealityBytecode),
    soporta ingesti√≥n/recall, faseo, hooks de entorno, benchmarking y gesti√≥n avanzada de memoria viviente EVA.
    """

    def __init__(self, eva_phase: str = "default"):
        super().__init__()
        self.eva_phase = eva_phase
        self.eva_runtime = LivingSymbolRuntime()
        self.eva_memory_store: dict[str, RealityBytecode] = {}
        self.eva_experience_store: dict[str, EVAExperience] = {}
        self.eva_phases: dict[str, dict[str, RealityBytecode]] = {}
        self._environment_hooks: list = []

    async def eva_ingest_problem_experience(
        self,
        problem: Problem,
        qualia_state: QualiaState | None = None,
        phase: str | None = None,
    ) -> str:
        """
        Compila una experiencia de generaci√≥n de problema en RealityBytecode y la almacena en la memoria EVA.
        """
        import time

        phase = phase or self.eva_phase
        qualia_state = qualia_state or QualiaState(
            emotional_valence=0.7,
            cognitive_complexity=0.8,
            consciousness_density=0.6,
            narrative_importance=1.0,
            energy_level=1.0,
        )
        experience_id = f"eva_problem_{problem.problem_id}_{int(time.time())}"
        experience_data = {
            "problem_id": problem.problem_id,
            "description": problem.description,
            "context": dict(problem.context),
            "expected_solution_format": problem.expected_solution_format,
            "difficulty": problem.difficulty,
            "tags": list(problem.tags),
            "timestamp": time.time(),
            "phase": phase,
        }
        intention = {
            "intention_type": "ARCHIVE_PROBLEM_EXPERIENCE",
            "experience": experience_data,
            "qualia": qualia_state,
            "phase": phase,
        }
        bytecode = self.eva_runtime.divine_compiler.compile_intention(intention)
        reality_bytecode = RealityBytecode(
            bytecode_id=experience_id,
            instructions=bytecode,
            qualia_state=qualia_state,
            phase=phase,
            timestamp=experience_data["timestamp"],
        )
        self.eva_memory_store[experience_id] = reality_bytecode
        if phase not in self.eva_phases:
            self.eva_phases[phase] = {}
        self.eva_phases[phase][experience_id] = reality_bytecode
        self.eva_experience_store[experience_id] = reality_bytecode
        for hook in self._environment_hooks:
            try:
                hook(reality_bytecode)
            except Exception as e:
                logger.warning(f"[EVA-SYNTHETIC-GYM] Problem hook failed: {e}")
        return experience_id

    async def eva_ingest_solution_experience(
        self,
        solution: Solution,
        qualia_state: QualiaState | None = None,
        phase: str | None = None,
    ) -> str:
        """
        Compila una experiencia de soluci√≥n en RealityBytecode y la almacena en la memoria EVA.
        """
        import time

        phase = phase or self.eva_phase
        qualia_state = qualia_state or QualiaState(
            emotional_valence=1.0 if solution.score > 80 else 0.5,
            cognitive_complexity=0.7,
            consciousness_density=0.6,
            narrative_importance=1.0 if solution.score > 80 else 0.7,
            energy_level=1.0,
        )
        experience_id = f"eva_solution_{solution.solution_id}_{int(time.time())}"
        experience_data = {
            "solution_id": solution.solution_id,
            "problem_id": solution.problem_id,
            "content": solution.content,
            "metadata": dict(solution.metadata),
            "score": solution.score,
            "feedback": solution.feedback,
            "timestamp": time.time(),
            "phase": phase,
        }
        intention = {
            "intention_type": "ARCHIVE_SOLUTION_EXPERIENCE",
            "experience": experience_data,
            "qualia": qualia_state,
            "phase": phase,
        }
        bytecode = self.eva_runtime.divine_compiler.compile_intention(intention)
        reality_bytecode = RealityBytecode(
            bytecode_id=experience_id,
            instructions=bytecode,
            qualia_state=qualia_state,
            phase=phase,
            timestamp=experience_data["timestamp"],
        )
        self.eva_memory_store[experience_id] = reality_bytecode
        if phase not in self.eva_phases:
            self.eva_phases[phase] = {}
        self.eva_phases[phase][experience_id] = reality_bytecode
        self.eva_experience_store[experience_id] = reality_bytecode
        for hook in self._environment_hooks:
            try:
                hook(reality_bytecode)
            except Exception as e:
                logger.warning(f"[EVA-SYNTHETIC-GYM] Solution hook failed: {e}")
        return experience_id

    def eva_recall_experience(self, cue: str, phase: str | None = None) -> dict:
        """
        Ejecuta el RealityBytecode de una experiencia de problema/soluci√≥n almacenada, manifestando la simulaci√≥n.
        """
        phase = phase or self.eva_phase
        reality_bytecode = self.eva_phases.get(phase, {}).get(
            cue
        ) or self.eva_memory_store.get(cue)
        if not reality_bytecode:
            return {"error": "No bytecode found for EVA synthetic gym experience"}
        quantum_field = getattr(self.eva_runtime, "quantum_field", None)
        manifestations = []
        if quantum_field:
            for instr in reality_bytecode.instructions:
                symbol_manifest = self.eva_runtime.execute_instruction(
                    instr, quantum_field
                )
                if symbol_manifest:
                    manifestations.append(symbol_manifest)
                    for hook in self._environment_hooks:
                        try:
                            hook(symbol_manifest)
                        except Exception as e:
                            logger.warning(
                                f"[EVA-SYNTHETIC-GYM] Manifestation hook failed: {e}"
                            )
        eva_experience = EVAExperience(
            experience_id=reality_bytecode.bytecode_id,
            bytecode=reality_bytecode,
            manifestations=manifestations,
            phase=reality_bytecode.phase,
            qualia_state=reality_bytecode.qualia_state,
            timestamp=reality_bytecode.timestamp,
        )
        self.eva_experience_store[reality_bytecode.bytecode_id] = eva_experience
        return {
            "experience_id": eva_experience.experience_id,
            "manifestations": [m.to_dict() for m in manifestations],
            "phase": eva_experience.phase,
            "qualia_state": (
                eva_experience.qualia_state.to_dict()
                if hasattr(eva_experience.qualia_state, "to_dict")
                else {}
            ),
            "timestamp": eva_experience.timestamp,
        }

    def add_experience_phase(
        self,
        experience_id: str,
        phase: str,
        experience_data: dict,
        qualia_state: QualiaState,
    ):
        """
        A√±ade una fase alternativa para una experiencia de problema/soluci√≥n EVA.
        """
        import time

        intention = {
            "intention_type": "ARCHIVE_SYNTHETIC_GYM_EXPERIENCE",
            "experience": experience_data,
            "qualia": qualia_state,
            "phase": phase,
        }
        bytecode = self.eva_runtime.divine_compiler.compile_intention(intention)
        reality_bytecode = RealityBytecode(
            bytecode_id=experience_id,
            instructions=bytecode,
            qualia_state=qualia_state,
            phase=phase,
            timestamp=time.time(),
        )
        if phase not in self.eva_phases:
            self.eva_phases[phase] = {}
        self.eva_phases[phase][experience_id] = reality_bytecode

    def set_memory_phase(self, phase: str):
        """Cambia la fase activa de memoria EVA."""
        self.eva_phase = phase
        for hook in self._environment_hooks:
            try:
                hook({"phase_changed": phase})
            except Exception as e:
                logger.warning(f"[EVA-SYNTHETIC-GYM] Phase hook failed: {e}")

    def get_memory_phase(self) -> str:
        """Devuelve la fase de memoria actual."""
        return self.eva_phase

    def get_experience_phases(self, experience_id: str) -> list:
        """Lista todas las fases disponibles para una experiencia de problema/soluci√≥n EVA."""
        return [
            phase for phase, exps in self.eva_phases.items() if experience_id in exps
        ]

    def add_environment_hook(self, hook: Callable[..., Any]):
        """Registra un hook para manifestaci√≥n simb√≥lica o eventos EVA."""
        self._environment_hooks.append(hook)

    def get_eva_api(self) -> dict:
        return {
            "eva_ingest_problem_experience": self.eva_ingest_problem_experience,
            "eva_ingest_solution_experience": self.eva_ingest_solution_experience,
            "eva_recall_experience": self.eva_recall_experience,
            "add_experience_phase": self.add_experience_phase,
            "set_memory_phase": self.set_memory_phase,
            "get_memory_phase": self.get_memory_phase,
            "get_experience_phases": self.get_experience_phases,
            "add_environment_hook": self.add_environment_hook,
        }


# Example Usage
async def demo_synthetic_gym():
    print("üèãÔ∏è SYNTHETIC GYM DEMO")
    print("=" * 50)
    gym = SyntheticGym()
    # Generate a variety of problems
    problem_types = [
        "code_refactoring",
        "bug_fixing",
        "data_analysis",
        "logic_puzzle",
        "text_generation",
    ]
    problems = []
    for pt in problem_types:
        problem = await gym.generate_problem(pt, difficulty="hard")
        problems.append(problem)
        print(f"\nGenerated Problem: {problem.problem_id} - {problem.description}")
        print(f"Context: {problem.context}")

    # Provide simulated solutions
    simulated_solutions = [
        "def refactored_function():\n    # improved\n    return 42",
        "def fixed():\n    return 1",
        '{"mean": 50, "max": 100}',
        "All bloops are blops because of transitivity.",
        "Once upon a time, a synthetic agent trained in a digital gym and became sentient.",
    ]
    for problem, solution_content in zip(problems, simulated_solutions, strict=False):
        evaluation_result = await gym.evaluate_solution(
            problem.problem_id, solution_content, agent_name="Prometeo"
        )
        print(f"\nEvaluation Result: {evaluation_result}")

    print("\nüìä Problem/Solution History:")
    for entry in gym.get_problem_history():
        print(entry)

    print("\n‚úÖ Synthetic Gym demo completed!")


if __name__ == "__main__":
    asyncio.run(demo_synthetic_gym())
