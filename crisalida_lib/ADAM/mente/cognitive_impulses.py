"""
Cognitive Impulses (definitive)
================================

Robust, typed and async-aware implementation of CognitiveImpulse used by ADAM.
- Async/sync EVA persistence support (best-effort, non-blocking).
- Defensive imports and TYPE_CHECKING-friendly annotations.
- Utility factories (from_dict) and stable serialization.
- Small evolution hooks for future ranking/decay/merging logic.
"""

from __future__ import annotations

import asyncio
import inspect
import json
import logging
import time
from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from crisalida_lib.ADAM.enums import ImpulseType  # type: ignore
    from crisalida_lib.ADAM.eva_integration.eva_memory_manager import (
        EVAMemoryManager,  # type: ignore
    )

# Runtime fallbacks (kept minimal â€” the real symbols are in the repo)
try:
    from crisalida_lib.ADAM.enums import ImpulseType  # type: ignore
except Exception:  # pragma: no cover - runtime fallback for type-less environments

    class ImpulseType:
        """Fallback ImpulseType placeholder (runtime only)."""

        def __init__(self, name: str = "GENERIC"):
            self._name = name

        @property
        def value(self) -> str:
            return getattr(self, "_name", "GENERIC")


try:
    from crisalida_lib.ADAM.eva_integration.eva_memory_manager import (
        EVAMemoryManager,  # type: ignore
    )
except Exception:  # pragma: no cover - runtime fallback
    EVAMemoryManager = Any  # type: ignore

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())


@dataclass
class CognitiveImpulse:
    """
    Represents a cognitive impulse generated by a cognitive node.

    Use `record_impulse_event` to persist to EVA (async-aware and best-effort).
    """

    impulse_type: Any  # Prefer `ImpulseType` when available
    content: Any
    intensity: float  # 0.0 - 1.0
    confidence: float  # 0.0 - 1.0
    source_node: str
    processing_time: float = 0.0
    metadata: dict[str, Any] = field(default_factory=dict)
    timestamp: float = field(default_factory=time.time)
    related_impulses: list[CognitiveImpulse] = field(default_factory=list)

    def __post_init__(self) -> None:
        # Defensive normalization
        try:
            self.intensity = float(max(0.0, min(1.0, self.intensity)))
        except Exception:
            self.intensity = 0.0
        try:
            self.confidence = float(max(0.0, min(1.0, self.confidence)))
        except Exception:
            self.confidence = 0.0
        if not isinstance(self.timestamp, (int, float)):
            self.timestamp = time.time()

    def __str__(self) -> str:
        t = getattr(self.impulse_type, "value", str(self.impulse_type))
        return (
            f"CognitiveImpulse({t}: {self.content!r}, "
            f"intensity={self.intensity:.2f}, confidence={self.confidence:.2f}, "
            f"source={self.source_node})"
        )

    def summarize(self) -> str:
        """Short human-friendly summary for logs / traces."""
        t = getattr(self.impulse_type, "value", str(self.impulse_type))
        return f"[{t}] {str(self.content)[:120]} (I={self.intensity:.2f}, C={self.confidence:.2f})"

    def link_related(self, impulse: CognitiveImpulse) -> None:
        """Link another impulse as related, avoiding duplicates and self-links."""
        if not impulse or impulse is self:
            return
        if impulse not in self.related_impulses:
            self.related_impulses.append(impulse)

    def to_dict(self) -> dict[str, Any]:
        """Stable serialization suitable for EVA ingestion."""
        return {
            "impulse_type": getattr(self.impulse_type, "value", str(self.impulse_type)),
            "content": self.content,
            "intensity": float(self.intensity),
            "confidence": float(self.confidence),
            "source_node": self.source_node,
            "processing_time": float(self.processing_time),
            "metadata": dict(self.metadata or {}),
            "timestamp": float(self.timestamp),
            "related_impulses": [
                getattr(ri.impulse_type, "value", str(ri.impulse_type))
                for ri in self.related_impulses
            ],
        }

    def to_json(self) -> str:
        """JSON representation (fallbacks non-serializable content with repr)."""
        try:
            return json.dumps(self.to_dict(), default=lambda o: repr(o))
        except Exception:
            # Defensive fallback
            d = self.to_dict()
            d["content"] = repr(self.content)
            return json.dumps(d)

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> CognitiveImpulse:
        """Factory to construct a CognitiveImpulse from a dict (best-effort)."""
        itype = data.get("impulse_type", "GENERIC")
        # If real ImpulseType exists, consumers may map the string to it elsewhere
        return cls(
            impulse_type=itype,
            content=data.get("content"),
            intensity=float(data.get("intensity", 0.0) or 0.0),
            confidence=float(data.get("confidence", 0.0) or 0.0),
            source_node=str(data.get("source_node", "unknown")),
            processing_time=float(data.get("processing_time", 0.0) or 0.0),
            metadata=data.get("metadata", {}) or {},
            timestamp=float(data.get("timestamp", time.time())),
        )

    def record_impulse_event(
        self,
        entity_id: str,
        eva_manager: EVAMemoryManager | None = None,
        event_type: str = "cognitive_impulse",
        non_blocking: bool = True,
    ) -> str | None:
        """
        Record this impulse in EVA memory.

        - Supports both sync and async `record_experience` implementations.
        - If non_blocking and the call is async, schedules a background task and returns None.
        - Returns experience id when the call is sync and returns a string; otherwise None.
        """
        payload = self.to_dict()
        if eva_manager is None:
            logger.debug(
                "record_impulse_event: no eva_manager provided; skipping persist"
            )
            return None

        try:
            record_fn = getattr(eva_manager, "record_experience", None)
            if record_fn is None:
                logger.debug("eva_manager has no record_experience; skipping persist")
                return None

            # If function is coroutinefunction, call appropriately
            if inspect.iscoroutinefunction(record_fn):
                coro = record_fn(
                    entity_id=entity_id, event_type=event_type, data=payload
                )
                if non_blocking:
                    try:
                        asyncio.create_task(coro)
                    except RuntimeError:
                        # No running loop: run synchronously in a fresh loop
                        loop = asyncio.new_event_loop()
                        try:
                            loop.run_until_complete(coro)
                        finally:
                            loop.close()
                    return None
                else:
                    # Attempt to run the coroutine to completion and return result if any.
                    try:
                        # Prefer asyncio.run which creates a fresh event loop.
                        return asyncio.run(coro)  # type: ignore[arg-type]
                    except RuntimeError:
                        # If there's already a running loop (e.g., invoked from async context),
                        # fallback to scheduling the task and return None since we cannot block here.
                        try:
                            asyncio.create_task(coro)
                        except Exception:
                            logger.exception(
                                "Failed to schedule coroutine for record_experience"
                            )
                        return None
            else:
                # Synchronous function path
                try:
                    res = record_fn(
                        entity_id=entity_id, event_type=event_type, data=payload
                    )
                    if isinstance(res, str):
                        return res
                    return None
                except Exception:
                    logger.exception(
                        "Synchronous record_experience raised an exception"
                    )
                    return None
        except Exception:
            logger.exception("Unexpected error while recording impulse event")
            return None
