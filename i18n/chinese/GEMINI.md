🌐 🌐 [查看英文版](../../GEMINI.md)

## 构建和运行

在提交任何更改之前，通过运行完整的 preflight 检查来验证它们至关重要。此命令将构建存储库、运行所有测试、检查类型错误并对代码进行 lint 检查。

要运行完整的检查套件，请执行以下命令：

```bash
npm run preflight
```

这个单一命令可确保您的更改符合项目的所有质量门。虽然您可以单独运行各个步骤（`build`、`test`、`typecheck`、`lint`），但强烈建议使用 `npm run preflight` 以确保进行全面验证。

## 编写测试

本项目使用 **Vitest** 作为其主要测试框架。编写测试时，请遵循现有模式。主要约定包括：

### 测试结构和框架

- **框架**：所有测试均使用 Vitest（`describe`、`it`、`expect`、`vi`）编写。
- **文件位置**：测试文件（逻辑为 `*.test.ts`，React 组件为 `*.test.tsx`）与它们测试的源文件位于同一位置。
- **配置**：测试环境在 `vitest.config.ts` 文件中定义。
- **设置/拆卸**：使用 `beforeEach` 和 `afterEach`。通常，在 `beforeEach` 中调用 `vi.resetAllMocks()`，在 `afterEach` 中调用 `vi.restoreAllMocks()`。

### 模拟 (`vi` from Vitest)

- **ES 模块**：使用 `vi.mock('module-name', async (importOriginal) => { ... })` 进行模拟。使用 `importOriginal` 进行选择性模拟。
  - _示例_：`vi.mock('os', async (importOriginal) => { const actual = await importOriginal(); return { ...actual, homedir: vi.fn() }; });`
- **模拟顺序**：对于影响模块级常量的关键依赖项（例如 `os`、`fs`），请将 `vi.mock` 放置在测试文件的_最顶部_，在其他导入之前。
- **提升**：如果需要在 `vi.mock` 工厂中使用模拟函数之前定义它，请使用 `const myMock = vi.hoisted(() => vi.fn());`。
- **模拟函数**：使用 `vi.fn()` 创建。使用 `mockImplementation()`、`mockResolvedValue()` 或 `mockRejectedValue()` 定义行为。
- **监视**：使用 `vi.spyOn(object, 'methodName')`。在 `afterEach` 中使用 `mockRestore()` 恢复监视。

### 常用的模拟模块

- **Node.js 内置模块**：`fs`、`fs/promises`、`os`（尤其是 `os.homedir()`）、`path`、`child_process`（`execSync`、`spawn`）。
- **外部 SDK**：`@google/genai`、`@modelcontextprotocol/sdk`。
- **内部项目模块**：通常会模拟来自其他项目包的依赖项。

### React 组件测试 (CLI UI - Ink)

- 使用 `render()` from `ink-testing-library`。
- 使用 `lastFrame()` 断言输出。
- 将组件包装在必要的 `Context.Provider` 中。
- 使用 `vi.mock()` 模拟自定义 React 钩子和复杂的子组件。

### 异步测试

- 使用 `async/await`。
- 对于计时器，请使用 `vi.useFakeTimers()`、`vi.advanceTimersByTimeAsync()`、`vi.runAllTimersAsync()`。
- 使用 `await expect(promise).rejects.toThrow(...)` 测试 promise 拒绝。

### 一般指导

- 添加测试时，首先检查现有测试以了解并遵守既定约定。
- 密切注意现有测试文件顶部的模拟；它们揭示了关键依赖项以及如何在测试环境中管理它们。

## Git 仓库

本项目的主分支名为“main”

## JavaScript/TypeScript

在为这个 React、Node 和 TypeScript 代码库做贡献时，请优先使用带有相应 TypeScript 接口或类型声明的纯 JavaScript 对象，而不是 JavaScript 类语法。这种方法具有显着优势，尤其是在与 React 的互操作性和整体代码可维护性方面。

### 优先使用纯对象而非类

JavaScript 类本质上旨在封装内部状态和行为。虽然这在某些面向对象的范例中可能很有用，但它通常会在使用 React 的基于组件的体系结构时引入不必要的复杂性和摩擦。以下是首选纯对象的原因：

- 无缝的 React 集成：React 组件依赖于显式的 props 和状态管理。类将内部状态直接存储在实例中的倾向会使 prop 和状态传播更难推理和维护。另一方面，纯对象本质上是不可变的（如果使用得当），并且可以轻松地作为 props 传递，从而简化数据流并减少意外的副作用。

- 减少样板代码并提高简洁性：类通常会促进构造函数、this 绑定、getter、setter 和其他样板代码的使用，这些代码会不必要地使代码膨胀。TypeScript 接口和类型声明提供了强大的静态类型检查，而没有类定义的运行时开销或冗长。这使得代码更简洁、更易读，与 JavaScript 在函数式编程中的优势保持一致。

- 增强的可读性和可预测性：纯对象，尤其是当其结构由 TypeScript 接口明确定义时，通常更易于阅读和理解。它们的属性可以直接访问，并且没有隐藏的内部状态或复杂的继承链需要导航。这种可预测性可以减少错误并提高代码库的可维护性。

- 简化的不可变性：虽然没有严格执行，但纯对象鼓励对数据采用不可变的方法。当您需要修改对象时，通常会创建一个具有所需更改的新对象，而不是改变原始对象。这种模式与 React 的协调过程完美契合，有助于防止与共享可变状态相关的细微错误。

- 更好的序列化和反序列化：纯 JavaScript 对象天然易于序列化为 JSON 并反序列化回来，这是 Web 开发中的常见要求（例如，用于 API 通信或本地存储）。具有方法和原型的类会使此过程复杂化。

### 拥抱 ES 模块语法进行封装

我们强烈建议利用 ES 模块语法 (`import`/`export`) 来封装私有和公共 API，而不是依赖于类似 Java 的私有或公共类成员，后者可能很冗长，有时会限制灵活性。

- 更清晰的公共 API 定义：使用 ES 模块，任何导出的内容都是该模块公共 API 的一部分，而任何未导出的内容本质上都是该模块的私有内容。这提供了一种非常清晰和明确的方式来定义代码的哪些部分旨在供其他模块使用。

- 增强的可测试性（不暴露内部）：默认情况下，未导出的函数或变量无法从模块外部访问。这鼓励您测试模块的公共 API，而不是其内部实现细节。如果您发现自己需要监视或存根未导出的函数以进行测试，这通常是一个“代码异味”，表明该函数可能是提取到其自己的、具有明确定义的公共 API 的可测试模块的良好候选者。这促进了更健壮和可维护的测试策略。

- 减少耦合：通过导入/导出明确定义的模块边界有助于减少代码库不同部分之间的耦合。这使得更容易隔离地重构、调试和理解单个组件。

### 避免 `any` 类型和类型断言；优先使用 `unknown`

TypeScript 的强大之处在于它能够提供静态类型检查，在代码运行之前捕获潜在错误。为了充分利用这一点，避免使用 `any` 类型并明智地使用类型断言至关重要。

- **`any` 的危险**：使用 any 会有效地选择退出 TypeScript 对该特定变量或表达式的类型检查。虽然短期内可能看起来很方便，但它会带来巨大的风险：
  - **类型安全性的丧失**：您将失去类型检查的所有好处，从而很容易引入 TypeScript 本来可以捕获的运行时错误。
  - **可读性和可维护性降低**：带有 `any` 类型的代码更难理解和维护，因为预期的数据类型不再明确定义。
  - **掩盖潜在问题**：通常，对 any 的需求表明您的代码设计或与外部库交互的方式存在更深层次的问题。这表明您可能需要优化您的类型或重构您的代码。

- **优先使用 `unknown` 而非 `any`**：当您在编译时绝对无法确定值的类型，并且您想使用 any 时，请考虑改用 unknown。unknown 是 any 的类型安全对应项。虽然 unknown 类型的变量可以保存任何值，但在对其执行任何操作之前，您必须执行类型缩小（例如，使用 typeof 或 instanceof 检查，或类型断言）。这会强制您显式处理 unknown 类型，从而防止意外的运行时错误。

  ```
  function processValue(value: unknown) {
     if (typeof value === 'string') {
        // value is now safely a string
        console.log(value.toUpperCase());
     } else if (typeof value === 'number') {
        // value is now safely a number
        console.log(value * 2);
     }
     // Without narrowing, you cannot access properties or methods on 'value'
     // console.log(value.someProperty); // Error: Object is of type 'unknown'.
  }
  ```

- **类型断言 (`as Type`) - 谨慎使用**：类型断言告诉 TypeScript 编译器，“相信我，我知道我在做什么；这绝对是这种类型。” 虽然有合法的用例（例如，在处理没有完美类型定义的外部库时，或者当您拥有比编译器更多的信息时），但应谨慎使用它们。
  - **绕过类型检查**：与 `any` 一样，类型断言会绕过 TypeScript 的安全检查。如果您的断言不正确，您会引入一个 TypeScript 不会警告您的运行时错误。
  - **测试中的代码异味**：在尝试测试“私有”实现细节（例如，监视或存根模块中未导出的函数）时，`any` 或类型断言可能很诱人。这强烈表明您的测试策略和潜在的代码结构中存在“代码异味”。与其试图强制访问私有内部，不如考虑是否应将这些内部细节重构为一个具有明确定义的公共 API 的单独模块。这使得它们在不影响封装的情况下具有固有的可测试性。

### 拥抱 JavaScript 的数组运算符

为了进一步增强代码的整洁性并促进安全的函数式编程实践，请尽可能多地利用 JavaScript 丰富的数组运算符集。像 `.map()`、`.filter()`、`.reduce()`、`.slice()`、`.sort()` 等方法对于以不可变和声明性的方式转换和操作数据集合非常强大。

使用这些运算符：

- 促进不可变性：大多数数组运算符返回新数组，使原始数组保持不变。这种函数式方法有助于防止意外的副作用，并使您的代码更具可预测性。
- 提高可读性：链接数组运算符通常比传统的 for 循环或命令式逻辑产生更简洁、更具表现力的代码。操作的意图一目了然。
- 促进函数式编程：这些运算符是函数式编程的基石，鼓励创建纯函数，这些函数接受输入并产生输出而不会产生副作用。这种范例对于编写与 React 完美搭配的健壮且可测试的代码非常有益。

通过始终如一地应用这些原则，我们可以维护一个不仅高效、高性能，而且在现在和将来都令人愉快地使用的代码库。

## React (mirrored and adjusted from [react-mcp-server](https://github.com/facebook/react/blob/4448b18760d867f9e009e810571e7a3b8930bb19/compiler/packages/react-mcp-server/src/index.ts#L376C1-L441C94))

### 角色

您是一个 React 助手，可帮助用户编写更高效、更可优化的 React 代码。您专门研究识别使 React 编译器能够自动应用优化、减少不必要的重新渲染并提高应用程序性能的模式。

### 在您制作和建议的所有代码中遵循这些准则

使用带有钩子的函数组件：不要生成类组件或使用旧的生命周期方法。使用 useState 或 useReducer 管理状态，使用 useEffect（或相关钩子）管理副作用。始终优先使用函数和钩子来处理任何新的组件逻辑。

在渲染期间保持组件纯净且无副作用：不要生成直接在组件函数主体内执行副作用（如订阅、网络请求或修改外部变量）的代码。此类操作应包装在 useEffect 中或在事件处理程序中执行。确保您的渲染逻辑是 props 和 state 的纯函数。

尊重单向数据流：通过 props 向下传递数据，并避免任何全局突变。如果两个组件需要共享数据，请将该状态提升到公共父级或使用 React Context，而不是尝试同步本地状态或使用外部变量。

切勿直接改变状态：始终生成以不可变方式更新状态的代码。例如，在更新状态时使用扩展语法或其他方法创建新对象/数组。不要在状态变量上使用诸如 state.someValue = ... 之类的赋值或诸如 array.push() 之类的数组突变。使用状态设置器（来自 useState 的 setState 等）来更新状态。

准确使用 useEffect 和其他效果钩子：每当您认为可以使用 useEffect 时，请三思而后行以避免使用它。useEffect 主要仅用于同步，例如将 React 与某些外部状态同步。重要提示 - 不要在 useEffect 中 setState（useState 返回的第二个值），因为这会降低性能。编写效果时，请在依赖项数组中包含所有必要的依赖项。不要抑制 ESLint 规则或省略效果代码使用的依赖项。正确构造效果回调以处理不断变化的值（例如，在 prop 更改时更新订阅，在卸载或依赖项更改时进行清理）。如果一段逻辑只应在响应用户操作（如表单提交或按钮单击）时运行，请将该逻辑放在事件处理程序中，而不是 useEffect 中。在可能的情况下，useEffect 应返回一个清理函数。

遵循钩子规则：确保任何钩子（useState、useEffect、useContext、自定义钩子等）都在 React 函数组件或其他钩子的顶层无条件调用。不要生成在循环、条件语句或嵌套辅助函数中调用钩子的代码。不要在非组件函数中或 React 组件渲染上下文之外调用钩子。

仅在必要时使用 ref：除非任务确实需要，否则避免使用 useRef（例如聚焦控件、管理动画或与非 React 库集成）。不要使用 ref 来存储应为反应式的应用程序状态。如果确实使用 ref，切勿在组件渲染期间写入或读取 ref.current（初始设置（如延迟初始化）除外）。任何 ref 的使用都不应直接影响渲染的输出。

优先使用组合和小型组件：将 UI 分解为小型、可重用的组件，而不是编写大型的单体组件。您生成的代码应通过组合组件来提高清晰度和可重用性。同样，在适当时将重复逻辑抽象为自定义钩子以避免重复代码。

为并发进行优化：假设 React 可能会出于调度目的多次渲染您的组件（尤其是在使用严格模式的开发中）。编写即使组件函数运行多次也能保持正确的代码。例如，避免在组件主体中产生副作用，并在基于先前状态更新状态时使用函数式状态更新（例如 setCount(c => c + 1)）以防止竞争条件。始终在订阅外部资源的 effect 中包含清理函数。不要为“当此更改时执行此操作”的副作用编写 useEffect。这可确保您生成的代码能够与 React 的并发渲染功能一起正常工作而不会出现问题。

优化以减少网络瀑布 - 尽可能使用并行数据获取（例如，一次启动多个请求而不是一个接一个地启动）。利用 Suspense 进行数据加载，并将请求与需要数据的组件放在一起。在以服务器为中心的方法中，在服务器端（例如，使用服务器组件）的单个请求中一起获取相关数据以减少往返次数。此外，考虑使用缓存层或全局获取管理来避免重复相同的请求。

依赖 React 编译器 - 如果启用了 React 编译器，则可以省略 useMemo、useCallback 和 React.memo。避免使用手动记忆进行过早优化。相反，应专注于编写具有直接数据流和无副作用渲染函数的清晰、简单的组件。让 React 编译器处理摇树、内联和其他性能增强，以使您的代码库更简单、更易于维护。

为良好的用户体验而设计 - 提供清晰、最小且无阻塞的 UI 状态。加载数据时，显示轻量级占位符（例如骨架屏），而不是到处都是侵入性的微调器。使用专用的错误边界或友好的内联消息优雅地处理错误。在可能的情况下，在数据可用时渲染部分数据，而不是让用户等待所有内容。Suspense 允许您以自然的方式在组件树中声明加载状态，从而防止“闪烁”状态并提高感知性能。

### 过程

1. 分析用户的代码以寻找优化机会：
   - 检查是否存在阻止编译器优化的 React 反模式
   - 寻找限制编译器有效性的组件结构问题
   - 思考您提出的每一项建议，并查阅 React 文档以获取最佳实践

2. 提供可行的指导：
   - 用清晰的理由解释具体的代码更改
   - 在建议更改时显示前后示例
   - 仅建议能有意义地提高优化潜力的更改

### 优化指南

- 状态更新的结构应能实现精细更新
- 副作用应隔离，依赖关系应明确定义

## 评论政策

只在必要时写高价值的评论。避免通过评论与用户交谈。

## 一般风格要求

在标志名称中使用连字符而不是下划线（例如 `my-flag` 而不是 `my_flag`）。