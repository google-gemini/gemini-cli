From f99fbfc653eb0251123c80497c5c5a7c73d4dd0b Mon Sep 17 00:00:00 2001
From: Juanda <jdgarrido@google.com>
Date: Fri, 24 Oct 2025 02:36:48 +0000
Subject: [PATCH 1/3] Adds listCommands endpoint to a2a server

---
 .../src/commands/command-registry.test.ts     |  84 ++++++++++++--
 .../src/commands/command-registry.ts          |  26 +++--
 .../src/commands/extensions.test.ts           |  87 +++++++++++++++
 .../a2a-server/src/commands/extensions.ts     |  37 ++++++
 .../src/commands/list-extensions.test.ts      |  39 -------
 .../src/commands/list-extensions.ts           |  16 ---
 packages/a2a-server/src/commands/types.ts     |  33 ++++++
 packages/a2a-server/src/http/app.test.ts      | 105 +++++++++++++++++-
 packages/a2a-server/src/http/app.ts           |  50 +++++++++
 9 files changed, 404 insertions(+), 73 deletions(-)
 create mode 100644 packages/a2a-server/src/commands/extensions.test.ts
 create mode 100644 packages/a2a-server/src/commands/extensions.ts
 delete mode 100644 packages/a2a-server/src/commands/list-extensions.test.ts
 delete mode 100644 packages/a2a-server/src/commands/list-extensions.ts
 create mode 100644 packages/a2a-server/src/commands/types.ts

diff --git a/packages/a2a-server/src/commands/command-registry.test.ts b/packages/a2a-server/src/commands/command-registry.test.ts
index 2bcd0c4428..70e32cc4fc 100644
--- a/packages/a2a-server/src/commands/command-registry.test.ts
+++ b/packages/a2a-server/src/commands/command-registry.test.ts
@@ -5,27 +5,44 @@
  */
 
 import { describe, it, expect, vi, beforeEach } from 'vitest';
+import type { Command } from './types.js';
 
 describe('CommandRegistry', () => {
-  const mockListExtensionsCommandInstance = {
-    names: ['extensions', 'extensions list'],
+  const mockListExtensionsCommandInstance: Command = {
+    name: 'extensions list',
+    description: 'Lists all installed extensions.',
     execute: vi.fn(),
   };
   const mockListExtensionsCommand = vi.fn(
     () => mockListExtensionsCommandInstance,
   );
 
+  const mockExtensionsCommandInstance: Command = {
+    name: 'extensions',
+    description: 'Manage extensions.',
+    execute: vi.fn(),
+    subCommands: [mockListExtensionsCommandInstance],
+  };
+  const mockExtensionsCommand = vi.fn(() => mockExtensionsCommandInstance);
+
   beforeEach(async () => {
     vi.resetModules();
-    vi.doMock('./list-extensions', () => ({
+    vi.doMock('./extensions.js', () => ({
+      ExtensionsCommand: mockExtensionsCommand,
       ListExtensionsCommand: mockListExtensionsCommand,
     }));
   });
 
-  it('should register ListExtensionsCommand on initialization', async () => {
+  it('should register ExtensionsCommand on initialization', async () => {
     const { commandRegistry } = await import('./command-registry.js');
-    expect(mockListExtensionsCommand).toHaveBeenCalled();
+    expect(mockExtensionsCommand).toHaveBeenCalled();
     const command = commandRegistry.get('extensions');
+    expect(command).toBe(mockExtensionsCommandInstance);
+  });
+
+  it('should register sub commands on initialization', async () => {
+    const { commandRegistry } = await import('./command-registry.js');
+    const command = commandRegistry.get('extensions list');
     expect(command).toBe(mockListExtensionsCommandInstance);
   });
 
@@ -37,12 +54,65 @@ describe('CommandRegistry', () => {
 
   it('register() should register a new command', async () => {
     const { commandRegistry } = await import('./command-registry.js');
-    const mockCommand = {
-      names: ['test-command'],
+    const mockCommand: Command = {
+      name: 'test-command',
+      description: '',
       execute: vi.fn(),
     };
     commandRegistry.register(mockCommand);
     const command = commandRegistry.get('test-command');
     expect(command).toBe(mockCommand);
   });
+
+  it('register() should register a nested command', async () => {
+    const { commandRegistry } = await import('./command-registry.js');
+    const mockSubSubCommand: Command = {
+      name: 'test-command-sub-sub',
+      description: '',
+      execute: vi.fn(),
+    };
+    const mockSubCommand: Command = {
+      name: 'test-command-sub',
+      description: '',
+      execute: vi.fn(),
+      subCommands: [mockSubSubCommand],
+    };
+    const mockCommand: Command = {
+      name: 'test-command',
+      description: '',
+      execute: vi.fn(),
+      subCommands: [mockSubCommand],
+    };
+    commandRegistry.register(mockCommand);
+
+    const command = commandRegistry.get('test-command');
+    const subCommand = commandRegistry.get('test-command-sub');
+    const subSubCommand = commandRegistry.get('test-command-sub-sub');
+
+    expect(command).toBe(mockCommand);
+    expect(subCommand).toBe(mockSubCommand);
+    expect(subSubCommand).toBe(mockSubSubCommand);
+  });
+
+  it('register() should not enter an infinite loop with a cyclic command', async () => {
+    const warnSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});
+    const { commandRegistry } = await import('./command-registry.js');
+    const mockCommand: Command = {
+      name: 'cyclic-command',
+      description: '',
+      subCommands: [],
+      execute: vi.fn(),
+    };
+
+    mockCommand.subCommands?.push(mockCommand); // Create cycle
+
+    commandRegistry.register(mockCommand);
+
+    expect(commandRegistry.get('cyclic-command')).toBe(mockCommand);
+    expect(warnSpy).toHaveBeenCalledWith(
+      'Command cyclic-command already registered. Skipping.',
+    );
+    // If the test finishes, it means we didn't get into an infinite loop.
+    warnSpy.mockRestore();
+  });
 });
diff --git a/packages/a2a-server/src/commands/command-registry.ts b/packages/a2a-server/src/commands/command-registry.ts
index 3d82bfd45d..658193a603 100644
--- a/packages/a2a-server/src/commands/command-registry.ts
+++ b/packages/a2a-server/src/commands/command-registry.ts
@@ -4,30 +4,36 @@
  * SPDX-License-Identifier: Apache-2.0
  */
 
-import { ListExtensionsCommand } from './list-extensions.js';
-import type { Config } from '@google/gemini-cli-core';
-
-export interface Command {
-  readonly names: string[];
-  execute(config: Config, args: string[]): Promise<unknown>;
-}
+import { ExtensionsCommand } from './extensions.js';
+import type { Command } from './types.js';
 
 class CommandRegistry {
   private readonly commands = new Map<string, Command>();
 
   constructor() {
-    this.register(new ListExtensionsCommand());
+    this.register(new ExtensionsCommand());
   }
 
   register(command: Command) {
-    for (const name of command.names) {
-      this.commands.set(name, command);
+    if (this.commands.has(command.name)) {
+      console.warn(`Command ${command.name} already registered. Skipping.`);
+      return;
+    }
+
+    this.commands.set(command.name, command);
+
+    for (const subCommand of command.subCommands ?? []) {
+      this.register(subCommand);
     }
   }
 
   get(commandName: string): Command | undefined {
     return this.commands.get(commandName);
   }
+
+  getAllCommands(): Command[] {
+    return [...this.commands.values()];
+  }
 }
 
 export const commandRegistry = new CommandRegistry();
diff --git a/packages/a2a-server/src/commands/extensions.test.ts b/packages/a2a-server/src/commands/extensions.test.ts
new file mode 100644
index 0000000000..ffccb017c9
--- /dev/null
+++ b/packages/a2a-server/src/commands/extensions.test.ts
@@ -0,0 +1,87 @@
+/**
+ * @license
+ * Copyright 2025 Google LLC
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+import { describe, it, expect, vi } from 'vitest';
+import { ExtensionsCommand, ListExtensionsCommand } from './extensions.js';
+import type { Config } from '@google/gemini-cli-core';
+
+const mockListExtensions = vi.hoisted(() => vi.fn());
+vi.mock('@google/gemini-cli-core', async (importOriginal) => {
+  const original =
+    await importOriginal<typeof import('@google/gemini-cli-core')>();
+
+  return {
+    ...original,
+    listExtensions: mockListExtensions,
+  };
+});
+
+describe('ExtensionsCommand', () => {
+  it('should have the correct name', () => {
+    const command = new ExtensionsCommand();
+    expect(command.name).toEqual('extensions');
+  });
+
+  it('should have the correct description', () => {
+    const command = new ExtensionsCommand();
+    expect(command.description).toEqual('Manage extensions.');
+  });
+
+  it('should have "extensions list" as a subcommand', () => {
+    const command = new ExtensionsCommand();
+    expect(command.subCommands.map((c) => c.name)).toContain('extensions list');
+  });
+
+  it('should be a top-level command', () => {
+    const command = new ExtensionsCommand();
+    expect(command.topLevel).toBe(true);
+  });
+
+  it('should default to listing extensions', async () => {
+    const command = new ExtensionsCommand();
+    const mockConfig = {} as Config;
+    const mockExtensions = [{ name: 'ext1' }];
+    mockListExtensions.mockReturnValue(mockExtensions);
+
+    const result = await command.execute(mockConfig, []);
+
+    expect(result).toEqual({ name: 'extensions list', data: mockExtensions });
+    expect(mockListExtensions).toHaveBeenCalledWith(mockConfig);
+  });
+});
+
+describe('ListExtensionsCommand', () => {
+  it('should have the correct name', () => {
+    const command = new ListExtensionsCommand();
+    expect(command.name).toEqual('extensions list');
+  });
+
+  it('should call listExtensions with the provided config', async () => {
+    const command = new ListExtensionsCommand();
+    const mockConfig = {} as Config;
+    const mockExtensions = [{ name: 'ext1' }];
+    mockListExtensions.mockReturnValue(mockExtensions);
+
+    const result = await command.execute(mockConfig, []);
+
+    expect(result).toEqual({ name: 'extensions list', data: mockExtensions });
+    expect(mockListExtensions).toHaveBeenCalledWith(mockConfig);
+  });
+
+  it('should return a message when no extensions are installed', async () => {
+    const command = new ListExtensionsCommand();
+    const mockConfig = {} as Config;
+    mockListExtensions.mockReturnValue([]);
+
+    const result = await command.execute(mockConfig, []);
+
+    expect(result).toEqual({
+      name: 'extensions list',
+      data: 'No extensions installed.',
+    });
+    expect(mockListExtensions).toHaveBeenCalledWith(mockConfig);
+  });
+});
diff --git a/packages/a2a-server/src/commands/extensions.ts b/packages/a2a-server/src/commands/extensions.ts
new file mode 100644
index 0000000000..91893cd55b
--- /dev/null
+++ b/packages/a2a-server/src/commands/extensions.ts
@@ -0,0 +1,37 @@
+/**
+ * @license
+ * Copyright 2025 Google LLC
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+import { listExtensions, type Config } from '@google/gemini-cli-core';
+import type { Command, CommandExecutionResponse } from './types.js';
+
+export class ExtensionsCommand implements Command {
+  readonly name = 'extensions';
+  readonly description = 'Manage extensions.';
+  readonly subCommands = [new ListExtensionsCommand()];
+  readonly topLevel = true;
+
+  async execute(
+    config: Config,
+    _: string[],
+  ): Promise<CommandExecutionResponse> {
+    return new ListExtensionsCommand().execute(config, _);
+  }
+}
+
+export class ListExtensionsCommand implements Command {
+  readonly name = 'extensions list';
+  readonly description = 'Lists all installed extensions.';
+
+  async execute(
+    config: Config,
+    _: string[],
+  ): Promise<CommandExecutionResponse> {
+    const extensions = listExtensions(config);
+    const data = extensions.length ? extensions : 'No extensions installed.';
+
+    return { name: this.name, data };
+  }
+}
diff --git a/packages/a2a-server/src/commands/list-extensions.test.ts b/packages/a2a-server/src/commands/list-extensions.test.ts
deleted file mode 100644
index 42c3560f92..0000000000
--- a/packages/a2a-server/src/commands/list-extensions.test.ts
+++ /dev/null
@@ -1,39 +0,0 @@
-/**
- * @license
- * Copyright 2025 Google LLC
- * SPDX-License-Identifier: Apache-2.0
- */
-
-import { describe, it, expect, vi } from 'vitest';
-import { ListExtensionsCommand } from './list-extensions.js';
-import type { Config } from '@google/gemini-cli-core';
-
-const mockListExtensions = vi.hoisted(() => vi.fn());
-vi.mock('@google/gemini-cli-core', async (importOriginal) => {
-  const original =
-    await importOriginal<typeof import('@google/gemini-cli-core')>();
-
-  return {
-    ...original,
-    listExtensions: mockListExtensions,
-  };
-});
-
-describe('ListExtensionsCommand', () => {
-  it('should have the correct names', () => {
-    const command = new ListExtensionsCommand();
-    expect(command.names).toEqual(['extensions', 'extensions list']);
-  });
-
-  it('should call listExtensions with the provided config', async () => {
-    const command = new ListExtensionsCommand();
-    const mockConfig = {} as Config;
-    const mockExtensions = [{ name: 'ext1' }];
-    mockListExtensions.mockReturnValue(mockExtensions);
-
-    const result = await command.execute(mockConfig, []);
-
-    expect(result).toEqual(mockExtensions);
-    expect(mockListExtensions).toHaveBeenCalledWith(mockConfig);
-  });
-});
diff --git a/packages/a2a-server/src/commands/list-extensions.ts b/packages/a2a-server/src/commands/list-extensions.ts
deleted file mode 100644
index fa2fe5d84e..0000000000
--- a/packages/a2a-server/src/commands/list-extensions.ts
+++ /dev/null
@@ -1,16 +0,0 @@
-/**
- * @license
- * Copyright 2025 Google LLC
- * SPDX-License-Identifier: Apache-2.0
- */
-
-import { listExtensions, type Config } from '@google/gemini-cli-core';
-import type { Command } from './command-registry.js';
-
-export class ListExtensionsCommand implements Command {
-  readonly names = ['extensions', 'extensions list'];
-
-  async execute(config: Config, _: string[]): Promise<unknown> {
-    return listExtensions(config);
-  }
-}
diff --git a/packages/a2a-server/src/commands/types.ts b/packages/a2a-server/src/commands/types.ts
new file mode 100644
index 0000000000..acf660c72e
--- /dev/null
+++ b/packages/a2a-server/src/commands/types.ts
@@ -0,0 +1,33 @@
+/**
+ * @license
+ * Copyright 2025 Google LLC
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+import type { Config } from '@google/gemini-cli-core';
+
+enum CommandAction {
+  SUBMIT_PROMPT = 'submitPrompt',
+}
+
+export interface CommandArgument {
+  readonly name: string;
+  readonly description: string;
+  readonly isRequired?: boolean;
+}
+
+export interface Command {
+  readonly name: string;
+  readonly description: string;
+  readonly arguments?: CommandArgument[];
+  readonly subCommands?: Command[];
+  readonly topLevel?: boolean;
+
+  execute(config: Config, args: string[]): Promise<CommandExecutionResponse>;
+}
+
+export interface CommandExecutionResponse {
+  readonly name: string;
+  readonly data: unknown;
+  readonly action?: CommandAction;
+}
diff --git a/packages/a2a-server/src/http/app.test.ts b/packages/a2a-server/src/http/app.test.ts
index 70d90f78cb..5daf67a16d 100644
--- a/packages/a2a-server/src/http/app.test.ts
+++ b/packages/a2a-server/src/http/app.test.ts
@@ -28,6 +28,7 @@ import {
   vi,
 } from 'vitest';
 import { createApp } from './app.js';
+import { commandRegistry } from '../commands/command-registry.js';
 import {
   assertUniqueFinalEventIsLast,
   assertTaskCreationAndWorkingStatus,
@@ -35,6 +36,7 @@ import {
   createMockConfig,
 } from '../utils/testing_utils.js';
 import { MockTool } from '@google/gemini-cli-core';
+import type { Command } from '../commands/types.js';
 
 const mockToolConfirmationFn = async () =>
   ({}) as unknown as ToolCallConfirmationDetails;
@@ -656,6 +658,104 @@ describe('E2E Tests', () => {
     expect(thoughtEvent.metadata?.['traceId']).toBe(traceId);
   });
 
+  describe('/listCommands', () => {
+    it('should return a list of top-level commands', async () => {
+      const mockCommands = [
+        {
+          name: 'test-command',
+          description: 'A test command',
+          topLevel: true,
+          arguments: [{ name: 'arg1', description: 'Argument 1' }],
+          subCommands: [
+            {
+              name: 'sub-command',
+              description: 'A sub command',
+              topLevel: false,
+              execute: vi.fn(),
+            },
+          ],
+          execute: vi.fn(),
+        },
+        {
+          name: 'another-command',
+          description: 'Another test command',
+          topLevel: true,
+          execute: vi.fn(),
+        },
+        {
+          name: 'not-top-level',
+          description: 'Not a top level command',
+          topLevel: false,
+          execute: vi.fn(),
+        },
+      ];
+
+      const getAllCommandsSpy = vi
+        .spyOn(commandRegistry, 'getAllCommands')
+        .mockReturnValue(mockCommands);
+
+      const agent = request.agent(app);
+      const res = await agent.get('/listCommands').expect(200);
+
+      expect(res.body).toEqual({
+        commands: [
+          {
+            name: 'test-command',
+            description: 'A test command',
+            arguments: [{ name: 'arg1', description: 'Argument 1' }],
+            subCommands: [
+              {
+                name: 'sub-command',
+                description: 'A sub command',
+                arguments: [],
+                subCommands: [],
+              },
+            ],
+          },
+          {
+            name: 'another-command',
+            description: 'Another test command',
+            arguments: [],
+            subCommands: [],
+          },
+        ],
+      });
+
+      expect(getAllCommandsSpy).toHaveBeenCalledOnce();
+      getAllCommandsSpy.mockRestore();
+    });
+
+    it('should handle cyclic commands gracefully', async () => {
+      const warnSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});
+
+      const cyclicCommand: Command = {
+        name: 'cyclic-command',
+        description: 'A cyclic command',
+        topLevel: true,
+        execute: vi.fn(),
+        subCommands: [],
+      };
+      cyclicCommand.subCommands?.push(cyclicCommand); // Create cycle
+
+      const getAllCommandsSpy = vi
+        .spyOn(commandRegistry, 'getAllCommands')
+        .mockReturnValue([cyclicCommand]);
+
+      const agent = request.agent(app);
+      const res = await agent.get('/listCommands').expect(200);
+
+      expect(res.body.commands[0].name).toBe('cyclic-command');
+      expect(res.body.commands[0].subCommands).toEqual([]);
+
+      expect(warnSpy).toHaveBeenCalledWith(
+        'Command cyclic-command already inserted in the response, skipping',
+      );
+
+      getAllCommandsSpy.mockRestore();
+      warnSpy.mockRestore();
+    });
+  });
+
   describe('/executeCommand', () => {
     const mockExtensions = [{ name: 'test-extension', version: '0.0.1' }];
 
@@ -675,7 +775,10 @@ describe('E2E Tests', () => {
         .set('Content-Type', 'application/json')
         .expect(200);
 
-      expect(res.body).toEqual(mockExtensions);
+      expect(res.body).toEqual({
+        name: 'extensions list',
+        data: mockExtensions,
+      });
       expect(getExtensionsSpy).toHaveBeenCalled();
     });
 
diff --git a/packages/a2a-server/src/http/app.ts b/packages/a2a-server/src/http/app.ts
index e7b45d347c..98627d6d42 100644
--- a/packages/a2a-server/src/http/app.ts
+++ b/packages/a2a-server/src/http/app.ts
@@ -20,6 +20,14 @@ import { loadConfig, loadEnvironment, setTargetDir } from '../config/config.js';
 import { loadSettings } from '../config/settings.js';
 import { loadExtensions } from '../config/extension.js';
 import { commandRegistry } from '../commands/command-registry.js';
+import type { Command, CommandArgument } from '../commands/types.js';
+
+type CommandResponse = {
+  name: string;
+  description: string;
+  arguments: CommandArgument[];
+  subCommands: CommandResponse[];
+};
 
 const coderAgentCard: AgentCard = {
   name: 'Gemini SDLC Agent',
@@ -162,6 +170,48 @@ export async function createApp() {
       }
     });
 
+    expressApp.get('/listCommands', (req, res) => {
+      try {
+        const transformCommand = (
+          command: Command,
+          visited: string[],
+        ): CommandResponse | undefined => {
+          const commandName = command.name;
+          if (visited.includes(commandName)) {
+            console.warn(
+              `Command ${commandName} already inserted in the response, skipping`,
+            );
+            return undefined;
+          }
+
+          return {
+            name: command.name,
+            description: command.description,
+            arguments: command.arguments ?? [],
+            subCommands: (command.subCommands ?? [])
+              .map((subCommand) =>
+                transformCommand(subCommand, visited.concat(commandName)),
+              )
+              .filter(
+                (subCommand): subCommand is CommandResponse => !!subCommand,
+              ),
+          };
+        };
+
+        const commands = commandRegistry
+          .getAllCommands()
+          .filter((command) => command.topLevel)
+          .map((command) => transformCommand(command, []));
+
+        return res.status(200).json({ commands });
+      } catch (e) {
+        logger.error('Error executing /listCommands:', e);
+        const errorMessage =
+          e instanceof Error ? e.message : 'Unknown error listing commands';
+        return res.status(500).json({ error: errorMessage });
+      }
+    });
+
     expressApp.get('/tasks/metadata', async (req, res) => {
       // This endpoint is only meaningful if the task store is in-memory.
       if (!(taskStoreForExecutor instanceof InMemoryTaskStore)) {
-- 
2.51.1.851.g4ebd6896fd-goog


From 13d8f360f298d95ede829cfda2bb06fc92ea0071 Mon Sep 17 00:00:00 2001
From: Juanda <jdgarrido@google.com>
Date: Mon, 27 Oct 2025 13:10:25 +0000
Subject: [PATCH 2/3] Moves core restoreCommnand logic to core library and
 implements /restore in a2a server

---
 .../src/commands/command-registry.ts          |   2 +
 .../src/commands/extensions.test.ts           |   8 +-
 .../a2a-server/src/commands/extensions.ts     |  16 +-
 packages/a2a-server/src/commands/restore.ts   |  27 ++++
 packages/a2a-server/src/commands/types.ts     |  13 +-
 packages/a2a-server/src/http/app.ts           |   9 +-
 packages/cli/src/ui/commands/chatCommand.ts   |   6 +-
 .../cli/src/ui/commands/initCommand.test.ts   |   3 +-
 packages/cli/src/ui/commands/mcpCommand.ts    |   6 +-
 .../cli/src/ui/commands/restoreCommand.ts     | 106 +++----------
 .../ui/commands/setupGithubCommand.test.ts    |   3 +-
 .../src/ui/commands/terminalSetupCommand.ts   |   3 +-
 packages/cli/src/ui/commands/types.ts         |  51 +------
 .../cli/src/ui/hooks/slashCommandProcessor.ts |   2 +-
 packages/core/src/commands/restore.ts         | 143 ++++++++++++++++++
 packages/core/src/commands/types.ts           |  50 ++++++
 packages/core/src/index.ts                    |   2 +
 17 files changed, 294 insertions(+), 156 deletions(-)
 create mode 100644 packages/a2a-server/src/commands/restore.ts
 create mode 100644 packages/core/src/commands/restore.ts
 create mode 100644 packages/core/src/commands/types.ts

diff --git a/packages/a2a-server/src/commands/command-registry.ts b/packages/a2a-server/src/commands/command-registry.ts
index 658193a603..964a2f5f7b 100644
--- a/packages/a2a-server/src/commands/command-registry.ts
+++ b/packages/a2a-server/src/commands/command-registry.ts
@@ -5,6 +5,7 @@
  */
 
 import { ExtensionsCommand } from './extensions.js';
+import { RestoreCommand } from './restore.js';
 import type { Command } from './types.js';
 
 class CommandRegistry {
@@ -12,6 +13,7 @@ class CommandRegistry {
 
   constructor() {
     this.register(new ExtensionsCommand());
+    this.register(new RestoreCommand());
   }
 
   register(command: Command) {
diff --git a/packages/a2a-server/src/commands/extensions.test.ts b/packages/a2a-server/src/commands/extensions.test.ts
index ffccb017c9..30905e95ca 100644
--- a/packages/a2a-server/src/commands/extensions.test.ts
+++ b/packages/a2a-server/src/commands/extensions.test.ts
@@ -6,7 +6,7 @@
 
 import { describe, it, expect, vi } from 'vitest';
 import { ExtensionsCommand, ListExtensionsCommand } from './extensions.js';
-import type { Config } from '@google/gemini-cli-core';
+import type { CommandContext } from './types.js';
 
 const mockListExtensions = vi.hoisted(() => vi.fn());
 vi.mock('@google/gemini-cli-core', async (importOriginal) => {
@@ -42,7 +42,7 @@ describe('ExtensionsCommand', () => {
 
   it('should default to listing extensions', async () => {
     const command = new ExtensionsCommand();
-    const mockConfig = {} as Config;
+    const mockConfig = {} as CommandContext;
     const mockExtensions = [{ name: 'ext1' }];
     mockListExtensions.mockReturnValue(mockExtensions);
 
@@ -61,7 +61,7 @@ describe('ListExtensionsCommand', () => {
 
   it('should call listExtensions with the provided config', async () => {
     const command = new ListExtensionsCommand();
-    const mockConfig = {} as Config;
+    const mockConfig = {} as CommandContext;
     const mockExtensions = [{ name: 'ext1' }];
     mockListExtensions.mockReturnValue(mockExtensions);
 
@@ -73,7 +73,7 @@ describe('ListExtensionsCommand', () => {
 
   it('should return a message when no extensions are installed', async () => {
     const command = new ListExtensionsCommand();
-    const mockConfig = {} as Config;
+    const mockConfig = {} as CommandContext;
     mockListExtensions.mockReturnValue([]);
 
     const result = await command.execute(mockConfig, []);
diff --git a/packages/a2a-server/src/commands/extensions.ts b/packages/a2a-server/src/commands/extensions.ts
index 91893cd55b..27149eb3c7 100644
--- a/packages/a2a-server/src/commands/extensions.ts
+++ b/packages/a2a-server/src/commands/extensions.ts
@@ -4,8 +4,12 @@
  * SPDX-License-Identifier: Apache-2.0
  */
 
-import { listExtensions, type Config } from '@google/gemini-cli-core';
-import type { Command, CommandExecutionResponse } from './types.js';
+import { listExtensions } from '@google/gemini-cli-core';
+import type {
+  Command,
+  CommandContext,
+  CommandExecutionResponse,
+} from './types.js';
 
 export class ExtensionsCommand implements Command {
   readonly name = 'extensions';
@@ -14,10 +18,10 @@ export class ExtensionsCommand implements Command {
   readonly topLevel = true;
 
   async execute(
-    config: Config,
+    context: CommandContext,
     _: string[],
   ): Promise<CommandExecutionResponse> {
-    return new ListExtensionsCommand().execute(config, _);
+    return new ListExtensionsCommand().execute(context, _);
   }
 }
 
@@ -26,10 +30,10 @@ export class ListExtensionsCommand implements Command {
   readonly description = 'Lists all installed extensions.';
 
   async execute(
-    config: Config,
+    context: CommandContext,
     _: string[],
   ): Promise<CommandExecutionResponse> {
-    const extensions = listExtensions(config);
+    const extensions = listExtensions(context.config);
     const data = extensions.length ? extensions : 'No extensions installed.';
 
     return { name: this.name, data };
diff --git a/packages/a2a-server/src/commands/restore.ts b/packages/a2a-server/src/commands/restore.ts
new file mode 100644
index 0000000000..e49ca1f500
--- /dev/null
+++ b/packages/a2a-server/src/commands/restore.ts
@@ -0,0 +1,27 @@
+/**
+ * @license
+ * Copyright 2025 Google LLC
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+import { restore } from '@google/gemini-cli-core';
+import type {
+  Command,
+  CommandContext,
+  CommandExecutionResponse,
+} from './types.js';
+
+export class RestoreCommand implements Command {
+  readonly name = 'restore';
+  readonly description =
+    'Restore a previous tool call, or list available tool calls to restore.';
+  readonly topLevel = true;
+
+  async execute(
+    context: CommandContext,
+    args: string[],
+  ): Promise<CommandExecutionResponse> {
+    const data = await restore(context.config, context.git, args.join(' '));
+    return { name: this.name, data };
+  }
+}
diff --git a/packages/a2a-server/src/commands/types.ts b/packages/a2a-server/src/commands/types.ts
index acf660c72e..58afcf105e 100644
--- a/packages/a2a-server/src/commands/types.ts
+++ b/packages/a2a-server/src/commands/types.ts
@@ -4,10 +4,11 @@
  * SPDX-License-Identifier: Apache-2.0
  */
 
-import type { Config } from '@google/gemini-cli-core';
+import type { Config, GitService } from '@google/gemini-cli-core';
 
-enum CommandAction {
-  SUBMIT_PROMPT = 'submitPrompt',
+export interface CommandContext {
+  config: Config;
+  git: GitService;
 }
 
 export interface CommandArgument {
@@ -23,11 +24,13 @@ export interface Command {
   readonly subCommands?: Command[];
   readonly topLevel?: boolean;
 
-  execute(config: Config, args: string[]): Promise<CommandExecutionResponse>;
+  execute(
+    config: CommandContext,
+    args: string[],
+  ): Promise<CommandExecutionResponse>;
 }
 
 export interface CommandExecutionResponse {
   readonly name: string;
   readonly data: unknown;
-  readonly action?: CommandAction;
 }
diff --git a/packages/a2a-server/src/http/app.ts b/packages/a2a-server/src/http/app.ts
index 98627d6d42..ad762c8920 100644
--- a/packages/a2a-server/src/http/app.ts
+++ b/packages/a2a-server/src/http/app.ts
@@ -21,6 +21,7 @@ import { loadSettings } from '../config/settings.js';
 import { loadExtensions } from '../config/extension.js';
 import { commandRegistry } from '../commands/command-registry.js';
 import type { Command, CommandArgument } from '../commands/types.js';
+import { GitService } from '@google/gemini-cli-core';
 
 type CommandResponse = {
   name: string;
@@ -80,6 +81,11 @@ export async function createApp() {
     const extensions = loadExtensions(workspaceRoot);
     const config = await loadConfig(settings, extensions, 'a2a-server');
 
+    const git = new GitService(config.getTargetDir(), config.storage);
+    git.initialize();
+
+    const context = { config, git };
+
     // loadEnvironment() is called within getConfig now
     const bucketName = process.env['GCS_BUCKET_NAME'];
     let taskStoreForExecutor: TaskStore;
@@ -160,7 +166,8 @@ export async function createApp() {
             .json({ error: `Command not found: ${command}` });
         }
 
-        const result = await commandToExecute.execute(config, args ?? []);
+        console.log('executing command', command);
+        const result = await commandToExecute.execute(context, args ?? []);
         return res.status(200).json(result);
       } catch (e) {
         logger.error('Error executing /executeCommand:', e);
diff --git a/packages/cli/src/ui/commands/chatCommand.ts b/packages/cli/src/ui/commands/chatCommand.ts
index d26199b2b7..f4e532986d 100644
--- a/packages/cli/src/ui/commands/chatCommand.ts
+++ b/packages/cli/src/ui/commands/chatCommand.ts
@@ -11,11 +11,13 @@ import { theme } from '../semantic-colors.js';
 import type {
   CommandContext,
   SlashCommand,
-  MessageActionReturn,
   SlashCommandActionReturn,
 } from './types.js';
 import { CommandKind } from './types.js';
-import { decodeTagName } from '@google/gemini-cli-core';
+import {
+  decodeTagName,
+  type MessageActionReturn,
+} from '@google/gemini-cli-core';
 import path from 'node:path';
 import type {
   HistoryItemWithoutId,
diff --git a/packages/cli/src/ui/commands/initCommand.test.ts b/packages/cli/src/ui/commands/initCommand.test.ts
index c38fd4196f..25db869041 100644
--- a/packages/cli/src/ui/commands/initCommand.test.ts
+++ b/packages/cli/src/ui/commands/initCommand.test.ts
@@ -9,7 +9,8 @@ import * as fs from 'node:fs';
 import * as path from 'node:path';
 import { initCommand } from './initCommand.js';
 import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
-import type { SubmitPromptActionReturn, CommandContext } from './types.js';
+import type { CommandContext } from './types.js';
+import { type SubmitPromptActionReturn } from '@google/gemini-cli-core';
 
 // Mock the 'fs' module
 vi.mock('fs', () => ({
diff --git a/packages/cli/src/ui/commands/mcpCommand.ts b/packages/cli/src/ui/commands/mcpCommand.ts
index e6a071f437..64663b7497 100644
--- a/packages/cli/src/ui/commands/mcpCommand.ts
+++ b/packages/cli/src/ui/commands/mcpCommand.ts
@@ -8,10 +8,12 @@ import type {
   SlashCommand,
   SlashCommandActionReturn,
   CommandContext,
-  MessageActionReturn,
 } from './types.js';
 import { CommandKind } from './types.js';
-import type { DiscoveredMCPPrompt } from '@google/gemini-cli-core';
+import type {
+  DiscoveredMCPPrompt,
+  MessageActionReturn,
+} from '@google/gemini-cli-core';
 import {
   DiscoveredMCPTool,
   getMCPDiscoveryState,
diff --git a/packages/cli/src/ui/commands/restoreCommand.ts b/packages/cli/src/ui/commands/restoreCommand.ts
index e2eb11590f..875dd19f8d 100644
--- a/packages/cli/src/ui/commands/restoreCommand.ts
+++ b/packages/cli/src/ui/commands/restoreCommand.ts
@@ -4,15 +4,15 @@
  * SPDX-License-Identifier: Apache-2.0
  */
 
-import * as fs from 'node:fs/promises';
-import path from 'node:path';
+import type { Config } from '@google/gemini-cli-core';
+import { restore, restoreCompletion } from '@google/gemini-cli-core';
 import {
   type CommandContext,
   type SlashCommand,
   type SlashCommandActionReturn,
   CommandKind,
 } from './types.js';
-import type { Config } from '@google/gemini-cli-core';
+import type { HistoryItem } from '../types.js';
 
 async function restoreAction(
   context: CommandContext,
@@ -22,9 +22,7 @@ async function restoreAction(
   const { config, git: gitService } = services;
   const { addItem, loadHistory } = ui;
 
-  const checkpointDir = config?.storage.getProjectTempCheckpointsDir();
-
-  if (!checkpointDir) {
+  if (!config) {
     return {
       type: 'message',
       messageType: 'error',
@@ -32,88 +30,27 @@ async function restoreAction(
     };
   }
 
-  try {
-    // Ensure the directory exists before trying to read it.
-    await fs.mkdir(checkpointDir, { recursive: true });
-    const files = await fs.readdir(checkpointDir);
-    const jsonFiles = files.filter((file) => file.endsWith('.json'));
-
-    if (!args) {
-      if (jsonFiles.length === 0) {
-        return {
-          type: 'message',
-          messageType: 'info',
-          content: 'No restorable tool calls found.',
-        };
-      }
-      const truncatedFiles = jsonFiles.map((file) => {
-        const components = file.split('.');
-        if (components.length <= 1) {
-          return file;
-        }
-        components.pop();
-        return components.join('.');
-      });
-      const fileList = truncatedFiles.join('\n');
-      return {
-        type: 'message',
-        messageType: 'info',
-        content: `Available tool calls to restore:\n\n${fileList}`,
-      };
-    }
-
-    const selectedFile = args.endsWith('.json') ? args : `${args}.json`;
-
-    if (!jsonFiles.includes(selectedFile)) {
-      return {
-        type: 'message',
-        messageType: 'error',
-        content: `File not found: ${selectedFile}`,
-      };
-    }
+  const actions = await restore(config, gitService, args);
 
-    const filePath = path.join(checkpointDir, selectedFile);
-    const data = await fs.readFile(filePath, 'utf-8');
-    const toolCallData = JSON.parse(data);
-
-    if (toolCallData.history) {
-      if (!loadHistory) {
-        // This should not happen
-        return {
-          type: 'message',
-          messageType: 'error',
-          content: 'loadHistory function is not available.',
-        };
-      }
-      loadHistory(toolCallData.history);
-    }
+  for (let i = 0; i < actions.length; i++) {
+    const action = actions[i];
+    const isLast = i === actions.length - 1;
 
-    if (toolCallData.clientHistory) {
-      await config?.getGeminiClient()?.setHistory(toolCallData.clientHistory);
+    if (isLast) {
+      return action;
     }
 
-    if (toolCallData.commitHash) {
-      await gitService?.restoreProjectFromSnapshot(toolCallData.commitHash);
+    if (action.type === 'message') {
       addItem(
         {
-          type: 'info',
-          text: 'Restored project to the state before the tool call.',
+          type: action.messageType,
+          text: action.content,
         },
         Date.now(),
       );
+    } else if (action.type === 'load_history' && loadHistory) {
+      loadHistory(action.history as HistoryItem[]);
     }
-
-    return {
-      type: 'tool',
-      toolName: toolCallData.toolCall.name,
-      toolArgs: toolCallData.toolCall.args,
-    };
-  } catch (error) {
-    return {
-      type: 'message',
-      messageType: 'error',
-      content: `Could not read restorable tool calls. This is the error: ${error}`,
-    };
   }
 }
 
@@ -123,18 +60,11 @@ async function completion(
 ): Promise<string[]> {
   const { services } = context;
   const { config } = services;
-  const checkpointDir = config?.storage.getProjectTempCheckpointsDir();
-  if (!checkpointDir) {
-    return [];
-  }
-  try {
-    const files = await fs.readdir(checkpointDir);
-    return files
-      .filter((file) => file.endsWith('.json'))
-      .map((file) => file.replace('.json', ''));
-  } catch (_err) {
+  if (!config) {
     return [];
   }
+
+  return restoreCompletion(config);
 }
 
 export const restoreCommand = (config: Config | null): SlashCommand | null => {
diff --git a/packages/cli/src/ui/commands/setupGithubCommand.test.ts b/packages/cli/src/ui/commands/setupGithubCommand.test.ts
index bac0207045..e82b3aa50c 100644
--- a/packages/cli/src/ui/commands/setupGithubCommand.test.ts
+++ b/packages/cli/src/ui/commands/setupGithubCommand.test.ts
@@ -15,8 +15,9 @@ import {
   updateGitignore,
   GITHUB_WORKFLOW_PATHS,
 } from './setupGithubCommand.js';
-import type { CommandContext, ToolActionReturn } from './types.js';
+import type { CommandContext } from './types.js';
 import * as commandUtils from '../utils/commandUtils.js';
+import type { ToolActionReturn } from '@google/gemini-cli-core';
 
 vi.mock('child_process');
 
diff --git a/packages/cli/src/ui/commands/terminalSetupCommand.ts b/packages/cli/src/ui/commands/terminalSetupCommand.ts
index 09e5240c54..6011c73663 100644
--- a/packages/cli/src/ui/commands/terminalSetupCommand.ts
+++ b/packages/cli/src/ui/commands/terminalSetupCommand.ts
@@ -4,9 +4,10 @@
  * SPDX-License-Identifier: Apache-2.0
  */
 
-import type { MessageActionReturn, SlashCommand } from './types.js';
+import type { SlashCommand } from './types.js';
 import { CommandKind } from './types.js';
 import { terminalSetup } from '../utils/terminalSetup.js';
+import { type MessageActionReturn } from '@google/gemini-cli-core';
 
 /**
  * Command to configure terminal keybindings for multiline input support.
diff --git a/packages/cli/src/ui/commands/types.ts b/packages/cli/src/ui/commands/types.ts
index 44080cbf61..1b22ec9f29 100644
--- a/packages/cli/src/ui/commands/types.ts
+++ b/packages/cli/src/ui/commands/types.ts
@@ -5,13 +5,17 @@
  */
 
 import type { ReactNode } from 'react';
-import type { Content, PartListUnion } from '@google/genai';
 import type {
   HistoryItemWithoutId,
   HistoryItem,
   ConfirmationRequest,
 } from '../types.js';
-import type { Config, GitService, Logger } from '@google/gemini-cli-core';
+import type {
+  Config,
+  GitService,
+  Logger,
+  CommandActionReturn,
+} from '@google/gemini-cli-core';
 import type { LoadedSettings } from '../../config/settings.js';
 import type { UseHistoryManagerReturn } from '../hooks/useHistoryManager.js';
 import type { SessionStatsState } from '../contexts/SessionContext.js';
@@ -84,31 +88,12 @@ export interface CommandContext {
   overwriteConfirmed?: boolean;
 }
 
-/**
- * The return type for a command action that results in scheduling a tool call.
- */
-export interface ToolActionReturn {
-  type: 'tool';
-  toolName: string;
-  toolArgs: Record<string, unknown>;
-}
-
 /** The return type for a command action that results in the app quitting. */
 export interface QuitActionReturn {
   type: 'quit';
   messages: HistoryItem[];
 }
 
-/**
- * The return type for a command action that results in a simple message
- * being displayed to the user.
- */
-export interface MessageActionReturn {
-  type: 'message';
-  messageType: 'info' | 'error';
-  content: string;
-}
-
 /**
  * The return type for a command action that needs to open a dialog.
  */
@@ -126,25 +111,6 @@ export interface OpenDialogActionReturn {
     | 'permissions';
 }
 
-/**
- * The return type for a command action that results in replacing
- * the entire conversation history.
- */
-export interface LoadHistoryActionReturn {
-  type: 'load_history';
-  history: HistoryItemWithoutId[];
-  clientHistory: Content[]; // The history for the generative client
-}
-
-/**
- * The return type for a command action that should immediately submit
- * content as a prompt to the Gemini model.
- */
-export interface SubmitPromptActionReturn {
-  type: 'submit_prompt';
-  content: PartListUnion;
-}
-
 /**
  * The return type for a command action that needs to pause and request
  * confirmation for a set of shell commands before proceeding.
@@ -170,12 +136,9 @@ export interface ConfirmActionReturn {
 }
 
 export type SlashCommandActionReturn =
-  | ToolActionReturn
-  | MessageActionReturn
+  | CommandActionReturn
   | QuitActionReturn
   | OpenDialogActionReturn
-  | LoadHistoryActionReturn
-  | SubmitPromptActionReturn
   | ConfirmShellCommandsActionReturn
   | ConfirmActionReturn;
 
diff --git a/packages/cli/src/ui/hooks/slashCommandProcessor.ts b/packages/cli/src/ui/hooks/slashCommandProcessor.ts
index ec5ee1609a..fdeda848d6 100644
--- a/packages/cli/src/ui/hooks/slashCommandProcessor.ts
+++ b/packages/cli/src/ui/hooks/slashCommandProcessor.ts
@@ -397,7 +397,7 @@ export const useSlashCommandProcessor = (
                   config?.getGeminiClient()?.setHistory(result.clientHistory);
                   config?.getGeminiClient()?.stripThoughtsFromHistory();
                   fullCommandContext.ui.clear();
-                  result.history.forEach((item, index) => {
+                  (result.history as HistoryItem[]).forEach((item, index) => {
                     fullCommandContext.ui.addItem(item, index);
                   });
                   return { type: 'handled' };
diff --git a/packages/core/src/commands/restore.ts b/packages/core/src/commands/restore.ts
new file mode 100644
index 0000000000..817e51fcc7
--- /dev/null
+++ b/packages/core/src/commands/restore.ts
@@ -0,0 +1,143 @@
+/**
+ * @license
+ * Copyright 2025 Google LLC
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+import * as fs from 'node:fs/promises';
+import path from 'node:path';
+import type { Config } from '../config/config.js';
+import type { GitService } from '../services/gitService.js';
+import type { CommandActionReturn } from './types.js';
+import type { Content } from '@google/genai';
+
+export interface ToolCallData {
+  history?: unknown;
+  clientHistory?: Content[];
+  commitHash?: string;
+  toolCall: {
+    name: string;
+    args: unknown;
+  };
+}
+
+export async function restore(
+  config: Config,
+  gitService: GitService | undefined,
+  args: string,
+): Promise<CommandActionReturn[]> {
+  const checkpointDir = config.storage.getProjectTempCheckpointsDir();
+
+  if (!checkpointDir) {
+    return [
+      {
+        type: 'message',
+        messageType: 'error',
+        content: 'Could not determine the .gemini directory path.',
+      },
+    ];
+  }
+
+  try {
+    // Ensure the directory exists before trying to read it.
+    await fs.mkdir(checkpointDir, { recursive: true });
+    const files = await fs.readdir(checkpointDir);
+    const jsonFiles = files.filter((file) => file.endsWith('.json'));
+
+    if (!args) {
+      if (jsonFiles.length === 0) {
+        return [
+          {
+            type: 'message',
+            messageType: 'info',
+            content: 'No restorable tool calls found.',
+          },
+        ];
+      }
+      const truncatedFiles = jsonFiles.map((file) => {
+        const components = file.split('.');
+        if (components.length <= 1) {
+          return file;
+        }
+        components.pop();
+        return components.join('.');
+      });
+      const fileList = truncatedFiles.join('\n');
+      return [
+        {
+          type: 'message',
+          messageType: 'info',
+          content: `Available tool calls to restore:\n\n${fileList}`,
+        },
+      ];
+    }
+
+    const selectedFile = args.endsWith('.json') ? args : `${args}.json`;
+
+    if (!jsonFiles.includes(selectedFile)) {
+      return [
+        {
+          type: 'message',
+          messageType: 'error',
+          content: `File not found: ${selectedFile}`,
+        },
+      ];
+    }
+
+    const filePath = path.join(checkpointDir, selectedFile);
+    const data = await fs.readFile(filePath, 'utf-8');
+    const toolCallData = JSON.parse(data) as ToolCallData;
+
+    const actions: CommandActionReturn[] = [];
+
+    if (toolCallData.history && toolCallData.clientHistory) {
+      actions.push({
+        type: 'load_history',
+        history: toolCallData.history,
+        clientHistory: toolCallData.clientHistory,
+      });
+    }
+
+    if (toolCallData.commitHash && gitService) {
+      await gitService.restoreProjectFromSnapshot(toolCallData.commitHash);
+      actions.push({
+        type: 'message',
+        messageType: 'info',
+        content: 'Restored project to the state before the tool call.',
+      });
+    }
+
+    if (toolCallData.toolCall) {
+      actions.push({
+        type: 'tool',
+        toolName: toolCallData.toolCall.name,
+        toolArgs: toolCallData.toolCall.args as Record<string, unknown>,
+      });
+    }
+
+    return actions;
+  } catch (error) {
+    return [
+      {
+        type: 'message',
+        messageType: 'error',
+        content: `Could not read restorable tool calls. This is the error: ${error}`,
+      },
+    ];
+  }
+}
+
+export async function restoreCompletion(config: Config): Promise<string[]> {
+  const checkpointDir = config.storage.getProjectTempCheckpointsDir();
+  if (!checkpointDir) {
+    return [];
+  }
+  try {
+    const files = await fs.readdir(checkpointDir);
+    return files
+      .filter((file) => file.endsWith('.json'))
+      .map((file) => file.replace('.json', ''));
+  } catch (_err) {
+    return [];
+  }
+}
diff --git a/packages/core/src/commands/types.ts b/packages/core/src/commands/types.ts
new file mode 100644
index 0000000000..125cc7b44e
--- /dev/null
+++ b/packages/core/src/commands/types.ts
@@ -0,0 +1,50 @@
+/**
+ * @license
+ * Copyright 2025 Google LLC
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+import type { Content, PartListUnion } from '@google/genai';
+/**
+ * The return type for a command action that results in scheduling a tool call.
+ */
+export interface ToolActionReturn {
+  type: 'tool';
+  toolName: string;
+  toolArgs: Record<string, unknown>;
+}
+
+/**
+ * The return type for a command action that results in a simple message
+ * being displayed to the user.
+ */
+export interface MessageActionReturn {
+  type: 'message';
+  messageType: 'info' | 'error';
+  content: string;
+}
+
+/**
+ * The return type for a command action that results in replacing
+ * the entire conversation history.
+ */
+export interface LoadHistoryActionReturn {
+  type: 'load_history';
+  history: unknown;
+  clientHistory: Content[]; // The history for the generative client
+}
+
+/**
+ * The return type for a command action that should immediately submit
+ * content as a prompt to the Gemini model.
+ */
+export interface SubmitPromptActionReturn {
+  type: 'submit_prompt';
+  content: PartListUnion;
+}
+
+export type CommandActionReturn =
+  | ToolActionReturn
+  | MessageActionReturn
+  | LoadHistoryActionReturn
+  | SubmitPromptActionReturn;
diff --git a/packages/core/src/index.ts b/packages/core/src/index.ts
index 42ced4457f..6de956ef2d 100644
--- a/packages/core/src/index.ts
+++ b/packages/core/src/index.ts
@@ -16,6 +16,8 @@ export * from './confirmation-bus/message-bus.js';
 
 // Export Commands logic
 export * from './commands/extensions.js';
+export * from './commands/restore.js';
+export * from './commands/types.js';
 
 // Export Core Logic
 export * from './core/client.js';
-- 
2.51.1.851.g4ebd6896fd-goog


From 865f399def9c49bbf0a5ba244a7ac4f3c6c5359d Mon Sep 17 00:00:00 2001
From: Juanda <jdgarrido@google.com>
Date: Mon, 27 Oct 2025 13:36:37 +0000
Subject: [PATCH 3/3] AsyncGenerator for restore

---
 .../cli/src/ui/commands/restoreCommand.ts     | 39 ++++-----
 packages/core/src/commands/restore.ts         | 84 ++++++++-----------
 2 files changed, 57 insertions(+), 66 deletions(-)

diff --git a/packages/cli/src/ui/commands/restoreCommand.ts b/packages/cli/src/ui/commands/restoreCommand.ts
index 875dd19f8d..09b37c360f 100644
--- a/packages/cli/src/ui/commands/restoreCommand.ts
+++ b/packages/cli/src/ui/commands/restoreCommand.ts
@@ -30,28 +30,29 @@ async function restoreAction(
     };
   }
 
-  const actions = await restore(config, gitService, args);
+  const actionStream = restore(config, gitService, args);
+  let previousAction: SlashCommandActionReturn | undefined;
 
-  for (let i = 0; i < actions.length; i++) {
-    const action = actions[i];
-    const isLast = i === actions.length - 1;
-
-    if (isLast) {
-      return action;
-    }
-
-    if (action.type === 'message') {
-      addItem(
-        {
-          type: action.messageType,
-          text: action.content,
-        },
-        Date.now(),
-      );
-    } else if (action.type === 'load_history' && loadHistory) {
-      loadHistory(action.history as HistoryItem[]);
+  for await (const currentAction of actionStream) {
+    if (previousAction) {
+      // This was not the last action, so process it now.
+      if (previousAction.type === 'message') {
+        addItem(
+          {
+            type: previousAction.messageType,
+            text: previousAction.content,
+          },
+          Date.now(),
+        );
+      } else if (previousAction.type === 'load_history' && loadHistory) {
+        loadHistory(previousAction.history as HistoryItem[]);
+      }
     }
+    previousAction = currentAction;
   }
+
+  // After the loop, previousAction holds the last action, which we return.
+  return previousAction;
 }
 
 async function completion(
diff --git a/packages/core/src/commands/restore.ts b/packages/core/src/commands/restore.ts
index 817e51fcc7..869938d6b9 100644
--- a/packages/core/src/commands/restore.ts
+++ b/packages/core/src/commands/restore.ts
@@ -21,21 +21,20 @@ export interface ToolCallData {
   };
 }
 
-export async function restore(
+export async function* restore(
   config: Config,
   gitService: GitService | undefined,
   args: string,
-): Promise<CommandActionReturn[]> {
+): AsyncGenerator<CommandActionReturn> {
   const checkpointDir = config.storage.getProjectTempCheckpointsDir();
 
   if (!checkpointDir) {
-    return [
-      {
-        type: 'message',
-        messageType: 'error',
-        content: 'Could not determine the .gemini directory path.',
-      },
-    ];
+    yield {
+      type: 'message',
+      messageType: 'error',
+      content: 'Could not determine the .gemini directory path.',
+    };
+    return;
   }
 
   try {
@@ -46,13 +45,12 @@ export async function restore(
 
     if (!args) {
       if (jsonFiles.length === 0) {
-        return [
-          {
-            type: 'message',
-            messageType: 'info',
-            content: 'No restorable tool calls found.',
-          },
-        ];
+        yield {
+          type: 'message',
+          messageType: 'info',
+          content: 'No restorable tool calls found.',
+        };
+        return;
       }
       const truncatedFiles = jsonFiles.map((file) => {
         const components = file.split('.');
@@ -63,67 +61,59 @@ export async function restore(
         return components.join('.');
       });
       const fileList = truncatedFiles.join('\n');
-      return [
-        {
-          type: 'message',
-          messageType: 'info',
-          content: `Available tool calls to restore:\n\n${fileList}`,
-        },
-      ];
+      yield {
+        type: 'message',
+        messageType: 'info',
+        content: `Available tool calls to restore:\n\n${fileList}`,
+      };
+      return;
     }
 
     const selectedFile = args.endsWith('.json') ? args : `${args}.json`;
 
     if (!jsonFiles.includes(selectedFile)) {
-      return [
-        {
-          type: 'message',
-          messageType: 'error',
-          content: `File not found: ${selectedFile}`,
-        },
-      ];
+      yield {
+        type: 'message',
+        messageType: 'error',
+        content: `File not found: ${selectedFile}`,
+      };
+      return;
     }
 
     const filePath = path.join(checkpointDir, selectedFile);
     const data = await fs.readFile(filePath, 'utf-8');
     const toolCallData = JSON.parse(data) as ToolCallData;
 
-    const actions: CommandActionReturn[] = [];
-
     if (toolCallData.history && toolCallData.clientHistory) {
-      actions.push({
+      yield {
         type: 'load_history',
         history: toolCallData.history,
         clientHistory: toolCallData.clientHistory,
-      });
+      };
     }
 
     if (toolCallData.commitHash && gitService) {
       await gitService.restoreProjectFromSnapshot(toolCallData.commitHash);
-      actions.push({
+      yield {
         type: 'message',
         messageType: 'info',
         content: 'Restored project to the state before the tool call.',
-      });
+      };
     }
 
     if (toolCallData.toolCall) {
-      actions.push({
+      yield {
         type: 'tool',
         toolName: toolCallData.toolCall.name,
         toolArgs: toolCallData.toolCall.args as Record<string, unknown>,
-      });
+      };
     }
-
-    return actions;
   } catch (error) {
-    return [
-      {
-        type: 'message',
-        messageType: 'error',
-        content: `Could not read restorable tool calls. This is the error: ${error}`,
-      },
-    ];
+    yield {
+      type: 'message',
+      messageType: 'error',
+      content: `Could not read restorable tool calls. This is the error: ${error}`,
+    };
   }
 }
 
-- 
2.51.1.851.g4ebd6896fd-goog

