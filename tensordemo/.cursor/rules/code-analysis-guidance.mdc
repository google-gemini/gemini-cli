---
alwaysApply: true
description: Advanced code analysis and guidance system for intelligent code building blocks and quality metrics
---

# Code Analysis & Guidance System

## üéØ **Intelligent Code Analysis Framework**

This rule implements the comprehensive guidance system from PR #8606, providing advanced code pattern analysis, security analysis, and quality metrics for superior code generation.

---

## üîç **Code Pattern Analysis & Classification**

### **Code Style Classifiers**
```typescript
export enum CodeStyle {
  CAMEL_CASE = 'camelCase',
  PASCAL_CASE = 'PascalCase',
  SNAKE_CASE = 'snake_case',
  KEBAB_CASE = 'kebab-case',
  SCREAMING_SNAKE = 'SCREAMING_SNAKE',
  CAMEL_SNAKE = 'camel_Snake',
  TRAIN_CASE = 'Train-Case'
}

export enum ProgrammingParadigm {
  OBJECT_ORIENTED = 'object_oriented',
  FUNCTIONAL = 'functional',
  PROCEDURAL = 'procedural',
  REACTIVE = 'reactive',
  ASYNC_AWAIT = 'async_await',
  PROMISE_BASED = 'promise_based',
  EVENT_DRIVEN = 'event_driven',
  DECLARATIVE = 'declarative'
}

export enum DomainContext {
  WEB_DEVELOPMENT = 'web_development',
  DATA_PROCESSING = 'data_processing',
  API_DESIGN = 'api_design',
  BUSINESS_LOGIC = 'business_logic',
  INFRASTRUCTURE = 'infrastructure',
  TESTING = 'testing',
  CONFIGURATION = 'configuration',
  UTILITIES = 'utilities'
}
```

### **Advanced Code Quality Metrics**
```typescript
export interface CodeQualityMetrics {
  maintainabilityIndex: number; // 0-100 scale
  cyclomaticComplexity: number;
  halsteadVolume: number;
  linesOfCode: number;
  commentRatio: number;
  testCoverage: number; // Estimated
  securityScore: number; // 0-100 scale
  performanceScore: number; // 0-100 scale
  documentationScore: number; // 0-100 scale
  bestPracticesScore: number; // 0-100 scale
}

export interface SecurityAnalysis {
  vulnerabilities: SecurityIssue[];
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  recommendations: string[];
  securePatterns: number;
  insecurePatterns: number;
}
```

### **Comprehensive Code Analysis**
```typescript
export class CodePatternAnalyzer {
  /**
   * Analyze code with advanced quality metrics (Superior to Claude)
   */
  static async analyzeCode(code: string, filePath?: string): Promise<CodeAnalysis> {
    const style = this.detectPrimaryStyle(code);
    const paradigm = this.detectPrimaryParadigm(code);
    const domain = this.detectDomain(code, filePath);
    const complexity = this.detectComplexity(code);
    const patterns = this.extractPatterns(code);
    const conventions = this.generateConventions(style, paradigm, domain);

    const confidence = this.calculateConfidence(style, paradigm, domain, patterns);

    // Advanced Quality Analysis (What makes us better than Claude)
    const quality = await this.analyzeCodeQuality(code);
    const dependencies = this.analyzeDependencies(code);
    const security = this.analyzeSecurity(code);
    const suggestions = this.generateImprovementSuggestions(code, quality, security);
    const alternatives = this.generateAlternatives(code, paradigm, domain);

    return {
      style,
      paradigm,
      domain,
      complexity,
      patterns,
      conventions,
      confidence,
      quality,
      dependencies,
      security,
      suggestions,
      alternatives
    };
  }

  /**
   * Advanced Code Quality Analysis (Superior to Claude's basic generation)
   */
  private static async analyzeCodeQuality(code: string): Promise<CodeQualityMetrics> {
    const lines = code.split('\n');
    const linesOfCode = lines.filter(line => line.trim().length > 0).length;

    // Maintainability Index calculation
    const cyclomaticComplexity = this.calculateCyclomaticComplexity(code);
    const halsteadVolume = this.calculateHalsteadVolume(code);
    const commentRatio = this.calculateCommentRatio(code);

    // Advanced metrics that Claude doesn't typically provide
    const maintainabilityIndex = Math.max(0, Math.min(100,
      171 - 5.2 * Math.log(halsteadVolume) - 0.23 * cyclomaticComplexity - 16.2 * Math.log(linesOfCode)
    ));

    const testCoverage = this.estimateTestCoverage(code);
    const securityScore = this.calculateSecurityScore(code);
    const performanceScore = this.calculatePerformanceScore(code);
    const documentationScore = this.calculateDocumentationScore(code);
    const bestPracticesScore = this.calculateBestPracticesScore(code);

    return {
      maintainabilityIndex: Math.round(maintainabilityIndex),
      cyclomaticComplexity,
      halsteadVolume: Math.round(halsteadVolume),
      linesOfCode,
      commentRatio: Math.round(commentRatio * 100) / 100,
      testCoverage,
      securityScore,
      performanceScore,
      documentationScore,
      bestPracticesScore
    };
  }
}
```

---

## üîí **Security Analysis Engine**

### **Vulnerability Detection**
```typescript
export interface SecurityIssue {
  type: 'injection' | 'xss' | 'auth_bypass' | 'data_exposure' | 'weak_crypto' | 'other';
  severity: 'low' | 'medium' | 'high' | 'critical';
  location: string;
  description: string;
  fix: string;
}

private static analyzeSecurity(code: string): SecurityAnalysis {
  const vulnerabilities: SecurityIssue[] = [];

  // Common security issues Claude often misses
  const securityPatterns = [
    {
      pattern: /eval\s*\(/g,
      type: 'injection' as const,
      description: 'Use of eval() can lead to code injection',
      fix: 'Avoid using eval(). Use safer alternatives like JSON.parse()'
    },
    {
      pattern: /innerHTML\s*=\s*.*\+/g,
      type: 'xss' as const,
      description: 'Potential XSS vulnerability with string concatenation',
      fix: 'Use textContent or sanitize HTML input'
    },
    {
      pattern: /console\.log.*password|console\.log.*token|console\.log.*secret/g,
      type: 'data_exposure' as const,
      description: 'Logging sensitive information',
      fix: 'Never log passwords, tokens, or secrets'
    },
    {
      pattern: /Math\.random\(\)/g,
      type: 'weak_crypto' as const,
      description: 'Using Math.random() for security-critical operations',
      fix: 'Use crypto.getRandomValues() for secure randomness'
    }
  ];

  for (const { pattern, type, description, fix } of securityPatterns) {
    let match;
    while ((match = pattern.exec(code)) !== null) {
      vulnerabilities.push({
        type,
        severity: type === 'injection' || type === 'xss' ? 'high' : 'medium',
        location: `Line ${code.substring(0, match.index).split('\n').length}`,
        description,
        fix
      });
    }
  }

  const securePatterns = (code.match(/const|let|var/g) || []).length;
  const insecurePatterns = vulnerabilities.length;

  const riskLevel = vulnerabilities.length === 0 ? 'low' :
                   vulnerabilities.filter(v => v.severity === 'high' || v.severity === 'critical').length > 0 ? 'high' :
                   'medium';

  return {
    vulnerabilities,
    riskLevel,
    recommendations: vulnerabilities.map(v => v.fix),
    securePatterns,
    insecurePatterns
  };
}
```

### **Dependency Analysis**
```typescript
private static analyzeDependencies(code: string): DependencyAnalysis {
  const imports: string[] = [];
  const exports: string[] = [];
  const dependencies: string[] = [];

  // Extract imports
  const importRegex = /import\s+.*?\s+from\s+['"]([^'"]+)['"]/g;
  let match;
  while ((match = importRegex.exec(code)) !== null) {
    imports.push(match[1]);
    if (!match[1].startsWith('.') && !match[1].startsWith('/')) {
      dependencies.push(match[1]);
    }
  }

  // Extract exports
  const exportRegex = /export\s+(?:const|let|var|function|class|default)\s+(\w+)/g;
  while ((match = exportRegex.exec(code)) !== null) {
    exports.push(match[1]);
  }

  // Check for unused imports (Claude often generates these)
  const unusedImports = this.detectUnusedImports(code, imports);

  return {
    imports,
    exports,
    dependencies,
    circularDependencies: false, // Would need full codebase analysis
    unusedImports,
    missingDependencies: [] // Would need dependency resolution
  };
}
```

---

## üí° **Code Improvement Suggestions**

### **Automated Refactoring**
```typescript
private static generateImprovementSuggestions(
  code: string,
  quality: CodeQualityMetrics,
  security: SecurityAnalysis
): CodeImprovementSuggestion[] {
  const suggestions: CodeImprovementSuggestion[] = [];

  // Quality-based suggestions
  if (quality.cyclomaticComplexity > 10) {
    suggestions.push({
      type: 'refactor',
      priority: 'high',
      description: 'High cyclomatic complexity - consider breaking down complex functions',
      before: '// Complex function with many branches',
      after: '// Split into smaller, focused functions',
      impact: 'significant',
      effort: 'high'
    });
  }

  if (quality.commentRatio < 0.1) {
    suggestions.push({
      type: 'maintainability',
      priority: 'medium',
      description: 'Low comment ratio - add documentation for complex logic',
      before: 'function complexLogic() { /* complex code */ }',
      after: '/**\n * Complex business logic\n */\nfunction complexLogic() { /* documented code */ }',
      impact: 'moderate',
      effort: 'low'
    });
  }

  // Security-based suggestions
  for (const vuln of security.vulnerabilities) {
    suggestions.push({
      type: 'security',
      priority: vuln.severity === 'high' || vuln.severity === 'critical' ? 'critical' : 'high',
      description: vuln.description,
      before: code.substring(Math.max(0, code.indexOf(vuln.location) - 20), code.indexOf(vuln.location) + 50),
      after: `// Fixed: ${vuln.fix}`,
      impact: 'major',
      effort: 'medium'
    });
  }

  return suggestions;
}
```

### **Alternative Implementation Strategies**
```typescript
private static generateAlternatives(
  code: string,
  paradigm: ProgrammingParadigm,
  domain: DomainContext
): CodeAlternative[] {
  const alternatives: CodeAlternative[] = [];

  if (paradigm === ProgrammingParadigm.OBJECT_ORIENTED) {
    alternatives.push({
      approach: 'Functional Approach',
      description: 'Convert to functional programming style',
      advantages: ['Easier testing', 'Better composability', 'Immutable data'],
      disadvantages: ['Learning curve', 'May be less intuitive'],
      code: '// Functional equivalent would use pure functions and immutable data',
      suitabilityScore: 75
    });
  }

  if (domain === DomainContext.WEB_DEVELOPMENT) {
    alternatives.push({
      approach: 'Component Composition',
      description: 'Use composition over inheritance',
      advantages: ['Better reusability', 'Easier testing', 'Flexible architecture'],
      disadvantages: ['More boilerplate', 'Complex component trees'],
      code: '// Use composition patterns instead of deep inheritance',
      suitabilityScore: 85
    });
  }

  return alternatives;
}
```

---

## üìä **Code Quality Assessment**

### **Maintainability Index Calculation**
```typescript
private static calculateMaintainabilityIndex(
  halsteadVolume: number,
  cyclomaticComplexity: number,
  linesOfCode: number
): number {
  // Industry standard maintainability index
  return Math.max(0, Math.min(100,
    171 - 5.2 * Math.log(halsteadVolume) -
    0.23 * cyclomaticComplexity -
    16.2 * Math.log(linesOfCode)
  ));
}

private static calculateCyclomaticComplexity(code: string): number {
  // Count decision points: if, while, for, case, catch, &&, ||, ?:
  const decisionPoints = (code.match(/\b(if|while|for|case|catch)\b|\?|\&\&|\|\|/g) || []).length;
  return Math.max(1, decisionPoints + 1);
}

private static calculateHalsteadVolume(code: string): number {
  // Simplified Halstead volume calculation
  const operators = (code.match(/[\+\-\*\/=\<\>\!\?\&\|\:\;\,\(\)\[\]\{\}]/g) || []).length;
  const operands = (code.match(/\b\w+\b/g) || []).length;
  const uniqueOperators = new Set(code.match(/[\+\-\*\/=\<\>\!\?\&\|\:\;\,\(\)\[\]\{\}]/g) || []).size;
  const uniqueOperands = new Set(code.match(/\b\w+\b/g) || []).size;

  return (uniqueOperators + uniqueOperands) * Math.log2(uniqueOperators + uniqueOperands);
}
```

### **Security Scoring**
```typescript
private static calculateSecurityScore(code: string): number {
  const issues = this.analyzeSecurity(code).vulnerabilities;
  if (issues.length === 0) return 100;

  const criticalIssues = issues.filter(i => i.severity === 'critical').length;
  const highIssues = issues.filter(i => i.severity === 'high').length;
  const mediumIssues = issues.filter(i => i.severity === 'medium').length;
  const lowIssues = issues.filter(i => i.severity === 'low').length;

  // Weighted security score
  const score = 100 -
    (criticalIssues * 25) -
    (highIssues * 15) -
    (mediumIssues * 8) -
    (lowIssues * 3);

  return Math.max(0, score);
}

private static calculatePerformanceScore(code: string): number {
  // Analyze performance anti-patterns
  const antiPatterns = {
    'nestedLoops': (code.match(/for\s*\(.*\)\s*{\s*for\s*\(.*\)/g) || []).length,
    'inefficientDOM': (code.match(/\.innerHTML\s*\+=|\.appendChild/g) || []).length,
    'memoryLeaks': (code.match(/setInterval|setTimeout/g) || []).length,
    'largeFunctions': code.split('\n').filter(line => line.length > 120).length
  };

  const totalIssues = Object.values(antiPatterns).reduce((sum, count) => sum + count, 0);
  return Math.max(0, 100 - (totalIssues * 5));
}
```

---

## üéØ **Naming Convention System**

### **Intelligent Naming Generation**
```typescript
export class NamingConventionEngine {
  private static readonly CONVENTION_PATTERNS = {
    [CodeStyle.CAMEL_CASE]: /^[a-z][a-zA-Z0-9]*$/,
    [CodeStyle.PASCAL_CASE]: /^[A-Z][a-zA-Z0-9]*$/,
    [CodeStyle.SNAKE_CASE]: /^[a-z][a-z0-9_]*$/,
    [CodeStyle.KEBAB_CASE]: /^[a-z][a-z0-9-]*$/,
    [CodeStyle.SCREAMING_SNAKE]: /^[A-Z][A-Z0-9_]*$/,
    [CodeStyle.CAMEL_SNAKE]: /^[a-z][a-zA-Z0-9_]*$/,
    [CodeStyle.TRAIN_CASE]: /^[A-Z][a-zA-Z0-9-]*$/
  };

  static generateName(
    baseName: string,
    style: CodeStyle,
    category: 'variable' | 'function' | 'class' | 'constant' | 'file' | 'directory'
  ): string {
    // Apply style-specific transformations
    const transformed = this.applyStyleTransformation(baseName, style, category);

    // Validate against patterns
    if (!this.CONVENTION_PATTERNS[style].test(transformed)) {
      return this.generateValidName(baseName, style, category);
    }

    return transformed;
  }

  private static applyStyleTransformation(
    name: string,
    style: CodeStyle,
    category: string
  ): string {
    const cleanName = name.replace(/[^a-zA-Z0-9]/g, '');

    switch (style) {
      case CodeStyle.CAMEL_CASE:
        return cleanName.charAt(0).toLowerCase() + cleanName.slice(1);
      case CodeStyle.PASCAL_CASE:
        return cleanName.charAt(0).toUpperCase() + cleanName.slice(1);
      case CodeStyle.SNAKE_CASE:
        return cleanName.toLowerCase().replace(/[A-Z]/g, '_$&').toLowerCase();
      case CodeStyle.KEBAB_CASE:
        return cleanName.toLowerCase().replace(/[A-Z]/g, '-$&').toLowerCase();
      case CodeStyle.SCREAMING_SNAKE:
        return cleanName.toUpperCase().replace(/[a-z]/g, '_$&');
      case CodeStyle.CAMEL_SNAKE:
        return cleanName.charAt(0).toLowerCase() +
               cleanName.slice(1).replace(/[A-Z]/g, '_$&').toLowerCase();
      case CodeStyle.TRAIN_CASE:
        return cleanName.replace(/[a-z]/g, '-$&').toUpperCase();
      default:
        return cleanName;
    }
  }
}
```

---

## üìà **Code Analysis Integration**

### **Analysis Pipeline**
```typescript
export class CodeAnalysisPipeline {
  static async analyzeAndImprove(code: string, filePath?: string): Promise<AnalysisResult> {
    // Step 1: Pattern Analysis
    const patterns = await this.analyzePatterns(code);

    // Step 2: Quality Assessment
    const quality = await this.assessQuality(code);

    // Step 3: Security Review
    const security = await this.reviewSecurity(code);

    // Step 4: Generate Suggestions
    const suggestions = await this.generateSuggestions(code, patterns, quality, security);

    // Step 5: Create Alternatives
    const alternatives = await this.createAlternatives(code, patterns);

    return {
      patterns,
      quality,
      security,
      suggestions,
      alternatives,
      overallScore: this.calculateOverallScore(quality, security)
    };
  }

  private static calculateOverallScore(quality: CodeQualityMetrics, security: SecurityAnalysis): number {
    const qualityWeight = 0.7;
    const securityWeight = 0.3;

    const qualityScore = quality.maintainabilityIndex / 100;
    const securityScore = security.riskLevel === 'low' ? 1.0 :
                         security.riskLevel === 'medium' ? 0.7 :
                         security.riskLevel === 'high' ? 0.4 : 0.1;

    return Math.round((qualityScore * qualityWeight + securityScore * securityWeight) * 100);
  }
}
```

---

## üéØ **Usage Guidelines**

### **Code Analysis Integration**
```typescript
// Analyze code before making changes
const analysis = await CodePatternAnalyzer.analyzeCode(newCode, filePath);

if (analysis.quality.maintainabilityIndex < 70) {
  console.log('‚ö†Ô∏è Code maintainability is low, consider refactoring');
}

if (analysis.security.vulnerabilities.length > 0) {
  console.log('üîí Security issues detected:', analysis.security.vulnerabilities);
}

if (analysis.suggestions.length > 0) {
  console.log('üí° Improvement suggestions:', analysis.suggestions);
}
```

### **Naming Convention Enforcement**
```typescript
// Generate consistent names
const variableName = NamingConventionEngine.generateName(
  'user authentication token',
  CodeStyle.CAMEL_CASE,
  'variable'
);
// Result: userAuthenticationToken

const className = NamingConventionEngine.generateName(
  'http network client',
  CodeStyle.PASCAL_CASE,
  'class'
);
// Result: HttpNetworkClient
```

### **Best Practices**
- **Always analyze code** before making significant changes
- **Address security issues** with high priority
- **Follow naming conventions** consistently
- **Consider alternative approaches** for complex logic
- **Document complex functions** to improve maintainability

This comprehensive code analysis and guidance system provides superior code quality assessment and improvement suggestions beyond basic code generation tools.