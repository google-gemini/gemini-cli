---
alwaysApply: true
description: Comprehensive testing and quality assurance framework for reliability improvements with automated validation
---

# Testing & Quality Assurance Framework

## 🎯 **Automated Quality Validation System**

This rule establishes comprehensive testing standards and quality assurance automation for reliability improvements, ensuring 100% reliability and performance optimization.

---

## 🧪 **Comprehensive Testing Strategy**

### **Multi-Layer Testing Architecture**
```typescript
export class QualityAssuranceSystem {
  private testSuites = new Map<string, TestSuite>();
  private qualityGates = new Map<string, QualityGate>();
  private performanceBenchmarks = new Map<string, Benchmark>();

  async runComprehensiveTests(): Promise<QualityReport> {
    const results: TestResult[] = [];

    // Unit Tests
    results.push(await this.runUnitTests());

    // Integration Tests
    results.push(await this.runIntegrationTests());

    // Performance Tests
    results.push(await this.runPerformanceTests());

    // Security Tests
    results.push(await this.runSecurityTests());

    // Cross-Platform Tests
    results.push(await this.runCrossPlatformTests());

    return this.generateQualityReport(results);
  }

  private async runUnitTests(): Promise<TestResult> {
    const unitTests = this.testSuites.get('unit') || [];
    const results = await Promise.all(
      unitTests.map(test => this.executeTest(test))
    );

    return {
      category: 'unit',
      passed: results.filter(r => r.passed).length,
      total: results.length,
      duration: results.reduce((sum, r) => sum + r.duration, 0),
      coverage: await this.calculateCoverage('unit')
    };
  }

  private async runIntegrationTests(): Promise<TestResult> {
    const integrationTests = this.testSuites.get('integration') || [];
    const results = await Promise.all(
      integrationTests.map(test => this.executeTest(test))
    );

    return {
      category: 'integration',
      passed: results.filter(r => r.passed).length,
      total: results.length,
      duration: results.reduce((sum, r) => sum + r.duration, 0),
      coverage: await this.calculateCoverage('integration')
    };
  }

  private async runPerformanceTests(): Promise<TestResult> {
    const benchmarks = Array.from(this.performanceBenchmarks.values());
    const results: PerformanceResult[] = [];

    for (const benchmark of benchmarks) {
      const result = await this.runBenchmark(benchmark);
      results.push(result);
    }

    return {
      category: 'performance',
      passed: results.filter(r => r.withinThreshold).length,
      total: results.length,
      duration: results.reduce((sum, r) => sum + r.duration, 0),
      performanceScore: this.calculatePerformanceScore(results)
    };
  }
}
```

### **Test Suite Configuration**
```typescript
export interface TestSuite {
  name: string;
  type: 'unit' | 'integration' | 'performance' | 'security' | 'cross-platform';
  tests: TestCase[];
  setup?: () => Promise<void>;
  teardown?: () => Promise<void>;
  timeout: number;
  retries: number;
}

export interface TestCase {
  name: string;
  description: string;
  execute: () => Promise<TestResult>;
  expectedDuration?: number;
  tags: string[];
  priority: 'low' | 'medium' | 'high' | 'critical';
}

export interface TestResult {
  testName: string;
  passed: boolean;
  duration: number;
  error?: string;
  output?: string;
  memoryUsage?: number;
  cpuUsage?: number;
}
```

---

## 🔬 **Advanced Testing Techniques**

### **Mutation Testing**
```typescript
export class MutationTestingEngine {
  private mutants: CodeMutant[] = [];
  private survivalRate: number = 0;

  async performMutationTesting(originalCode: string): Promise<MutationReport> {
    // Generate mutants
    this.mutants = await this.generateMutants(originalCode);

    // Run tests against each mutant
    const results = await Promise.all(
      this.mutants.map(async (mutant) => {
        const testResult = await this.runTestsAgainstMutant(mutant);
        return {
          mutant,
          killed: !testResult.passed,
          testDuration: testResult.duration
        };
      })
    );

    // Calculate metrics
    const killedMutants = results.filter(r => r.killed).length;
    const totalMutants = results.length;
    this.survivalRate = ((totalMutants - killedMutants) / totalMutants) * 100;

    return {
      totalMutants,
      killedMutants,
      survivalRate: this.survivalRate,
      mutationScore: (killedMutants / totalMutants) * 100,
      results
    };
  }

  private async generateMutants(code: string): Promise<CodeMutant[]> {
    const mutants: CodeMutant[] = [];

    // Arithmetic operator mutations
    const arithmeticOps = ['+', '-', '*', '/', '%'];
    for (const [index, op] of code.matchAll(/[\+\-\*\/%]/g)) {
      for (const newOp of arithmeticOps) {
        if (newOp !== op) {
          mutants.push({
            type: 'arithmetic',
            location: index,
            original: op,
            mutant: newOp,
            code: code.substring(0, index) + newOp + code.substring(index + 1)
          });
        }
      }
    }

    // Conditional mutations
    const conditionals = ['<', '>', '<=', '>=', '==', '!='];
    for (const [index, op] of code.matchAll(/[<>=!]+/g)) {
      for (const newOp of conditionals) {
        if (newOp !== op) {
          mutants.push({
            type: 'conditional',
            location: index,
            original: op,
            mutant: newOp,
            code: code.substring(0, index) + newOp + code.substring(index + op.length)
          });
        }
      }
    }

    return mutants;
  }
}
```

### **Property-Based Testing**
```typescript
export class PropertyBasedTester {
  private generators = new Map<string, Generator>();
  private properties: Property[] = [];

  async testProperties(): Promise<PropertyTestResult> {
    const results: PropertyResult[] = [];

    for (const property of this.properties) {
      const testResult = await this.testProperty(property);
      results.push(testResult);
    }

    return {
      propertiesTested: results.length,
      passed: results.filter(r => r.passed).length,
      failed: results.filter(r => r.failed).length,
      averageShrinks: results.reduce((sum, r) => sum + r.shrinks, 0) / results.length,
      results
    };
  }

  private async testProperty(property: Property): Promise<PropertyResult> {
    const inputs = await this.generateInputs(property.inputTypes);
    let failedCase: GeneratedInput | null = null;
    let shrinks = 0;

    for (const input of inputs) {
      try {
        const result = await property.testFunction(input);
        if (!result) {
          failedCase = input;
          break;
        }
      } catch (error) {
        failedCase = input;
        break;
      }
    }

    // Shrink failing case
    if (failedCase) {
      shrinks = await this.shrinkFailingCase(failedCase, property);
    }

    return {
      property: property.name,
      passed: !failedCase,
      failed: !!failedCase,
      shrinks,
      failingInput: failedCase,
      error: failedCase ? 'Property violation detected' : undefined
    };
  }

  private async shrinkFailingCase(
    failingCase: GeneratedInput,
    property: Property
  ): Promise<number> {
    let currentCase = failingCase;
    let shrinks = 0;

    while (await this.canShrink(currentCase, property)) {
      const smallerCase = await this.generateSmallerCase(currentCase, property);
      if (await this.testCase(smallerCase, property)) {
        currentCase = smallerCase;
        shrinks++;
      } else {
        break;
      }
    }

    return shrinks;
  }
}
```

---

## 📊 **Quality Metrics & Monitoring**

### **Real-Time Quality Dashboard**
```typescript
export class QualityDashboard {
  private metrics = new Map<string, QualityMetric>();
  private readonly updateInterval = 5000; // 5 seconds

  startMonitoring(): void {
    setInterval(() => {
      this.collectMetrics();
      this.analyzeTrends();
      this.generateAlerts();
    }, this.updateInterval);
  }

  private async collectMetrics(): Promise<void> {
    // Code Quality Metrics
    this.updateMetric('maintainability', await this.getMaintainabilityScore());
    this.updateMetric('test_coverage', await this.getTestCoverage());
    this.updateMetric('code_complexity', await this.getComplexityScore());
    this.updateMetric('technical_debt', await this.getTechnicalDebt());

    // Test Metrics
    this.updateMetric('test_success_rate', await this.getTestSuccessRate());
    this.updateMetric('test_execution_time', await this.getTestExecutionTime());
    this.updateMetric('flaky_tests', await this.getFlakyTestCount());

    // Performance Metrics
    this.updateMetric('build_time', await this.getBuildTime());
    this.updateMetric('deployment_frequency', await this.getDeploymentFrequency());
    this.updateMetric('mean_time_to_recovery', await this.getMTTR());
  }

  private updateMetric(name: string, value: number): void {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, {
        name,
        current: value,
        history: [],
        threshold: this.getDefaultThreshold(name),
        trend: 'stable'
      });
    }

    const metric = this.metrics.get(name)!;
    metric.current = value;
    metric.history.push({ timestamp: Date.now(), value });

    // Keep only last 100 measurements
    if (metric.history.length > 100) {
      metric.history.shift();
    }

    // Update trend
    metric.trend = this.calculateTrend(metric.history);
  }

  private calculateTrend(history: MetricPoint[]): 'improving' | 'degrading' | 'stable' {
    if (history.length < 5) return 'stable';

    const recent = history.slice(-5);
    const older = history.slice(-10, -5);

    const recentAvg = recent.reduce((sum, m) => sum + m.value, 0) / recent.length;
    const olderAvg = older.reduce((sum, m) => sum + m.value, 0) / older.length;

    const change = (recentAvg - olderAvg) / olderAvg;

    if (change > 0.05) return 'improving';
    if (change < -0.05) return 'degrading';
    return 'stable';
  }
}
```

### **Quality Gate System**
```typescript
export class QualityGateSystem {
  private gates = new Map<string, QualityGate>();

  constructor() {
    this.initializeDefaultGates();
  }

  private initializeDefaultGates(): void {
    // Code Quality Gates
    this.gates.set('code-quality', {
      name: 'code-quality',
      conditions: [
        { metric: 'maintainability', operator: '>=', value: 70 },
        { metric: 'complexity', operator: '<=', value: 15 },
        { metric: 'technical_debt', operator: '<=', value: 10 }
      ],
      action: 'block_merge',
      severity: 'high'
    });

    // Test Quality Gates
    this.gates.set('test-quality', {
      name: 'test-quality',
      conditions: [
        { metric: 'test_coverage', operator: '>=', value: 85 },
        { metric: 'test_success_rate', operator: '>=', value: 95 },
        { metric: 'flaky_tests', operator: '<=', value: 2 }
      ],
      action: 'require_review',
      severity: 'high'
    });

    // Performance Gates
    this.gates.set('performance', {
      name: 'performance',
      conditions: [
        { metric: 'build_time', operator: '<=', value: 300 }, // 5 minutes
        { metric: 'test_execution_time', operator: '<=', value: 600 }, // 10 minutes
        { metric: 'deployment_frequency', operator: '>=', value: 1 }
      ],
      action: 'warn',
      severity: 'medium'
    });
  }

  async evaluateGates(): Promise<GateEvaluationResult> {
    const results: GateResult[] = [];

    for (const gate of this.gates.values()) {
      const result = await this.evaluateGate(gate);
      results.push(result);
    }

    return {
      allPassed: results.every(r => r.passed),
      results,
      blockingGates: results.filter(r => !r.passed && r.gate.action === 'block_merge'),
      warnings: results.filter(r => !r.passed && r.gate.action === 'warn')
    };
  }

  private async evaluateGate(gate: QualityGate): Promise<GateResult> {
    const conditions = await Promise.all(
      gate.conditions.map(condition => this.evaluateCondition(condition))
    );

    const passed = conditions.every(c => c.result);

    return {
      gate: gate.name,
      passed,
      conditions,
      severity: gate.severity,
      message: passed ? 'All conditions met' : 'Some conditions failed'
    };
  }
}
```

---

## 🛡️ **Security Testing Framework**

### **Automated Security Validation**
```typescript
export class SecurityTestSuite {
  private vulnerabilities = new Map<string, SecurityVulnerability>();
  private attackVectors = new Map<string, AttackVector>();

  async runSecurityTests(): Promise<SecurityTestResult> {
    const results: SecurityTestResult[] = [];

    // Injection Tests
    results.push(await this.testInjectionAttacks());

    // XSS Tests
    results.push(await this.testXSSAttacks());

    // Authentication Tests
    results.push(await this.testAuthenticationBypass());

    // Authorization Tests
    results.push(await this.testAuthorizationBypass());

    // Data Exposure Tests
    results.push(await this.testDataExposure());

    return this.aggregateSecurityResults(results);
  }

  private async testInjectionAttacks(): Promise<SecurityTestResult> {
    const injectionTests = [
      { payload: "'; DROP TABLE users; --", expected: 'sanitized' },
      { payload: "$(rm -rf /)", expected: 'sanitized' },
      { payload: "{{7*7}}", expected: 'sanitized' }
    ];

    const passed = await Promise.all(
      injectionTests.map(test => this.testInjectionPayload(test))
    ).then(results => results.every(r => r));

    return {
      category: 'injection',
      passed,
      score: passed ? 100 : 0,
      vulnerabilities: passed ? [] : ['Injection vulnerability detected']
    };
  }

  private async testXSSAttacks(): Promise<SecurityTestResult> {
    const xssTests = [
      { payload: "<script>alert('XSS')</script>", expected: 'escaped' },
      { payload: "javascript:alert('XSS')", expected: 'blocked' },
      { payload: "<img src=x onerror=alert('XSS')>", expected: 'sanitized' }
    ];

    const passed = await Promise.all(
      xssTests.map(test => this.testXSSPayload(test))
    ).then(results => results.every(r => r));

    return {
      category: 'xss',
      passed,
      score: passed ? 100 : 0,
      vulnerabilities: passed ? [] : ['XSS vulnerability detected']
    };
  }
}
```

### **Penetration Testing Automation**
```typescript
export class PenetrationTestingEngine {
  private tools = new Map<string, PentestTool>();

  constructor() {
    this.initializeTools();
  }

  private initializeTools(): void {
    this.tools.set('sqlmap', {
      name: 'sqlmap',
      category: 'injection',
      execute: (target: string) => this.runSQLMap(target)
    });

    this.tools.set('xsstrike', {
      name: 'xsstrike',
      category: 'xss',
      execute: (target: string) => this.runXSStrike(target)
    });

    this.tools.set('nikto', {
      name: 'nikto',
      category: 'web',
      execute: (target: string) => this.runNikto(target)
    });
  }

  async runAutomatedPentest(target: string): Promise<PentestReport> {
    const results: ToolResult[] = [];

    // Run tools in parallel
    const toolPromises = Array.from(this.tools.values()).map(tool =>
      this.executeTool(tool, target)
    );

    const toolResults = await Promise.allSettled(toolPromises);

    for (let i = 0; i < toolResults.length; i++) {
      const result = toolResults[i];
      const tool = Array.from(this.tools.values())[i];

      if (result.status === 'fulfilled') {
        results.push({
          tool: tool.name,
          success: true,
          output: result.value,
          vulnerabilities: this.parseVulnerabilities(result.value)
        });
      } else {
        results.push({
          tool: tool.name,
          success: false,
          error: result.reason.message
        });
      }
    }

    return {
      target,
      timestamp: new Date(),
      results,
      totalVulnerabilities: results.reduce((sum, r) => sum + r.vulnerabilities.length, 0),
      criticalVulnerabilities: results.reduce((sum, r) =>
        sum + r.vulnerabilities.filter(v => v.severity === 'critical').length, 0),
      highVulnerabilities: results.reduce((sum, r) =>
        sum + r.vulnerabilities.filter(v => v.severity === 'high').length, 0)
    };
  }
}
```

---

## 📈 **Performance Benchmarking**

### **Automated Benchmarking System**
```typescript
export class BenchmarkingEngine {
  private benchmarks = new Map<string, Benchmark>();

  async runBenchmarks(): Promise<BenchmarkReport> {
    const results: BenchmarkResult[] = [];

    for (const [name, benchmark] of this.benchmarks) {
      const result = await this.executeBenchmark(benchmark);
      results.push(result);
    }

    return this.generateBenchmarkReport(results);
  }

  private async executeBenchmark(benchmark: Benchmark): Promise<BenchmarkResult> {
    const measurements: number[] = [];

    // Warm-up runs
    for (let i = 0; i < benchmark.warmupRuns; i++) {
      await benchmark.execute();
    }

    // Actual benchmark runs
    for (let i = 0; i < benchmark.iterations; i++) {
      const start = performance.now();
      await benchmark.execute();
      const end = performance.now();

      measurements.push(end - start);
    }

    const mean = measurements.reduce((sum, m) => sum + m, 0) / measurements.length;
    const median = this.calculateMedian(measurements);
    const stdDev = this.calculateStandardDeviation(measurements, mean);
    const min = Math.min(...measurements);
    const max = Math.max(...measurements);

    return {
      benchmark: benchmark.name,
      measurements,
      mean,
      median,
      stdDev,
      min,
      max,
      withinThreshold: mean <= benchmark.threshold
    };
  }

  private calculateMedian(values: number[]): number {
    const sorted = [...values].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 === 0
      ? (sorted[mid - 1] + sorted[mid]) / 2
      : sorted[mid];
  }

  private calculateStandardDeviation(values: number[], mean: number): number {
    const squaredDiffs = values.map(value => Math.pow(value - mean, 2));
    return Math.sqrt(squaredDiffs.reduce((sum, diff) => sum + diff, 0) / values.length);
  }
}
```

---

## 🎯 **Success Criteria & Validation**

### **Quality Gates**
- ✅ **Test Coverage**: 90%+ code coverage required
- ✅ **Security Score**: 95+ security score required
- ✅ **Performance**: All benchmarks within thresholds
- ✅ **Maintainability**: 70+ maintainability index required
- ✅ **Zero Critical Issues**: No critical vulnerabilities allowed

### **Automated Validation Pipeline**
```yaml
# GitHub Actions workflow for comprehensive quality assurance
name: Quality Assurance Pipeline
on: [pull_request, push]

jobs:
  quality-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:unit -- --coverage --coverageReporters=json

      - name: Run integration tests
        run: npm run test:integration

      - name: Run performance benchmarks
        run: npm run test:performance

      - name: Run security tests
        run: npm run test:security

      - name: Run mutation tests
        run: npm run test:mutation

      - name: Generate quality report
        run: npm run quality:report

      - name: Upload test results
        uses: actions/upload-artifact@v3
        with:
          name: quality-report
          path: quality-report.json
```

This comprehensive testing and quality assurance framework ensures 100% reliability and superior code quality for all reliability improvements.