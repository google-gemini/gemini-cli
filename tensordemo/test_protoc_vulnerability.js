#!/usr/bin/env tsx

/**
 * Test PROTOC vulnerability detection in Guidance.js security patterns
 */

console.log('🔍 Testing PROTOC Command Injection Vulnerability Detection...\n');

// Import GuidanceSystem dynamically
async function testProtoCVulnerability() {
  try {
    const { GuidanceSystem } = await import('./packages/core/src/utils/guidance.js');

    // Test the vulnerable PROTOC pattern from the security report
    const vulnerableCode = `
#!/bin/bash
COMPILED_PROTO_PATH="compiled_proto"

# VULNERABLE: Direct, unsanitized execution of the PROTOC environment variable
\${PROTOC} --cpp_out=\${COMPILED_PROTO_PATH} internal/proto/analytics/connections_log.proto
\${PROTOC} --cpp_out=\${COMPILED_PROTO_PATH} internal/proto/analytics/fast_pair_log.proto

# This should be flagged as supply-chain-injection
protoc --cpp_out=\${COMPILED_PROTO_PATH} internal/proto/analytics/test.proto
`;

    // Test the secure version
    const secureCode = `
#!/bin/bash
COMPILED_PROTO_PATH="compiled_proto"

# SECURE: Validate PROTOC before use
if [[ ! -f "\${PROTOC}" || ! -x "\${PROTOC}" ]]; then
  echo "Invalid PROTOC value: Not a valid executable file."
  exit 1
fi

# Safe execution with validation
"\${PROTOC}" --cpp_out="\${COMPILED_PROTO_PATH}" internal/proto/analytics/connections_log.proto
`;

    console.log('=== TESTING VULNERABLE CODE ===');
    const vulnerableAnalysis = GuidanceSystem.analyzeCode(vulnerableCode);
    console.log('Vulnerabilities found:', vulnerableAnalysis.security.vulnerabilities.length);
    vulnerableAnalysis.security.vulnerabilities.forEach(v => {
      console.log(`- ${v.severity}: ${v.type} - ${v.description}`);
    });

    console.log('\n=== TESTING SECURE CODE ===');
    const secureAnalysis = GuidanceSystem.analyzeCode(secureCode);
    console.log('Vulnerabilities found:', secureAnalysis.security.vulnerabilities.length);
    secureAnalysis.security.vulnerabilities.forEach(v => {
      console.log(`- ${v.severity}: ${v.type} - ${v.description}`);
    });

    // Check if PROTOC vulnerability was detected
    const protocVulnerabilities = vulnerableAnalysis.security.vulnerabilities.filter(
      v => v.description.includes('PROTOC') || v.description.includes('supply-chain')
    );

    if (protocVulnerabilities.length > 0) {
      console.log('\n✅ SUCCESS: PROTOC vulnerability detected!');
      protocVulnerabilities.forEach(v => {
        console.log(`   - ${v.severity} severity: ${v.description}`);
      });
    } else {
      console.log('\n❌ FAILED: PROTOC vulnerability not detected');
    }

    return protocVulnerabilities.length > 0;

  } catch (error) {
    console.error('❌ Test failed:', error);
    return false;
  }
}

// Run the test
testProtoCVulnerability().then(success => {
  console.log(`\n${success ? '🎉' : '💥'} PROTOC vulnerability detection test ${success ? 'PASSED' : 'FAILED'}`);
  process.exit(success ? 0 : 1);
});
